---
layout: post
title: Python 函数(13)  #标题
tagline: Python 教程
category: python      #分类
author: wali    #作者
tag: Python     #标签
ghurl:        #github url
ghurl_zip:   #github zip下载
comments: true

post_nav: ["1.定义函数","2.函数返回多个结果","3.序列解包","4.参数","5.变量的作用域","6.全局变量"]
group_tag: python3.7 教程
---

函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

# 1.定义函数

关键字 `def` 引入一个函数 定义。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进。

```python
def functionName(params):
  "函数文档字符串"
  pass
  return value
```

函数体的第一个语句可以（可选的）是`字符串文字`；这个`字符串文字`是函数的`文档字符串`或 `docstring` 。

函数的 `执行` 会引入一个用于函数局部变量的新符号表。 更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在`局部符号`表中查找，然后是`外层函数的局部符号表`，最后是`内置名称表`。 因此，`全局变量`和`外层函数的变量`不能在函数内部`直接赋值`（除非是在 global 语句中定义的全局变量，或者是在 nonlocal 语句中定义的外层函数的变量），尽管它们可以被引用。

在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过 按值调用 传递的（其中 值 始终是对象 引用 而不是对象的值）。1 当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。

定义一个Fibonacci 数列的函数
```python
def fib(n):
  """Print a Fibonacci series up to n """
  a, b = 0, 1
  while a < n
    print(a end=" ")
    a, b = b, a + b
  print()

fib(2000)

#输出
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

# 2.函数返回多个结果

python中当需要返回多个结果时，直接在`return`后面返回就可以了

```python
def test():
  a,b = 1, 2
  return a, b

h, j = test()
print(h,j)

# 输出
1,2
```

# 3.序列解包

将序列中的每个元素当成一个个个体剥离出来，这个过程就是解包
```python
a,b,c = 1,2,3
print(a,b,c)
# 输出 
1,2,3

a = 1,2,3
print(type(a))
print(a)
# 输出
<class tuple>
(1,2,3)

e,f,g = a
print(e,f,g)
#输出
1,2,3

#赋值给相同值
a=b=c=1
print(a,b,c)
1,1,1
```

# 4.参数

#### 必须参数
形参：在定义函数时的参数叫形参

实参：在函数调用时传递的参数叫实参

如果在定义函数时，定义了形参，那么在实参中必须与形参对应，否则会报错

```python
def add(x,y):
  return x + y

add(1,2)

```
如果在调用时只传递一个实参，那么程序将会报错

#### 关键字参数

关键字参数是以`key=value`的关键字参数来调用函数，关键字参数可以提高代码的可读性。

```python
def add(x,y):
  return x + y

add(y=3,x=2)
```

#### 默认参数

默认参数是在函数定义时给函数一个默认的参数

```python
def add(x,y=5)
  return x + y

add(1)
# 输出 
6

add(1,2)
#输出
3
```
`注意：默认参数必须放在非默认参数后面`

#### 任意的参数列表

任意数量的参数调用函数，这些参数会被包含在一个元组里，在可变数量的参数之前，可能会出现零个或多个普通参数。

```python
def write_multiple_items(file,separator, *args):
  file.write(separator.join(args))
```
一般来说，这些 可变参数 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 *args 参数之后的任何形式参数都是 ‘仅关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数。:

```python
def concat(*args, sep="/"):
  return sep.join(args)

concat("earth", "mars", "venus")
#输出
'earth/mars/venus'

concat("earth", "mars", "venus", sep=".")
#输出
'earth.mars.venus'
```

`注意：必须参数，关键字参数，可变参数之间的顺序是 必须参数->可变参数->关键字参数`

# 5.变量的作用域

在Python程序中创建、改变、查找变量名时，都是在一个保存变量名的空间中进行，我们称之为命名空间，也被称之为作用域。python的作用域是静态的，在源代码中变量名被赋值的位置决定了该变量能被访问的范围。即Python变量的作用域由变量所在源代码中的位置决定。变量查找顺序，`局部变量->全局变量->内置变量`

只有当变量在Module(模块)、Class(类)、def(函数)中定义的时候，才会有作用域的概念。

```python
a = 10

def func1():
  a = 5
  print(a)
print(a)

#输出 
5
10
```

#### python中没有块级作用域

```python
def func1():
  for i in range(0,9):
    sum = i
  print(sum)

func1()

#输出
8
```
从上面代码输出结果可以看到，我们在`for`中并定义`sum`变量，但是并没有在`func1`中定义，但是`print(sum)`可以看到打印出了结果，这个例子证明在python中没有块级作用域

# 6.全局变量

python模块中定义的变量都是全局变量，在整个模块任何地方都是可以使用。

#### 局部变量提升全局变量

```python
def func1():
  c =20
func1()
print(c)
```
上例代码会报错，控制台会输出`c`变量没有定义，因为局部变量没法在全局中调用

#### 提升局部变量的作用域

将上面代码修改下，将局部变量转换成全局变量

```python
def func1():
  global c
  c = 20
func1()
print(c)
# 输出
20
```
















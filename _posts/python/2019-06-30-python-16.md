---
layout: post
title: Python 正则(16)  #标题
tagline: python3.7 入门教程
category: python      #分类
author: wali    #作者
tag: Python     #标签
ghurl:        #github url
ghurl_zip:   #github zip下载
comments: true

post_nav: ["1.re模块中的参数说明","2.正则表达式对象","3.re模块内容","4.正则对象","5.匹配对象","6.正则前缀r","7.判断是否匹配成功","8.获取正则匹配内容","9.贪婪与非贪婪","10.正则替换"]
group_tag: python3.7 入门教程
---

正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。在python中使用正则需要先引入正则模块`re`。

- [python 正则表达式官方文档](https://docs.python.org/zh-cn/3/library/re.html "https://docs.python.org/zh-cn/3/library/re.html"){:target="_blank"}

# 1.re模块中的参数说明

参数|描述|
-|-|
pattern|正则匹配的表达式|
string|要匹配的字符串|
maxsplit|分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数|
flags|标志位，用于控制正则表达式的匹配方式|

#### 正则表达式修饰符 - 可选标志

修饰符|描述|
-|-|
re.A <br> re.ASCII|让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 (?a) |
re.DEBUG|显示编译时的debug信息，没有内联标记|
re.I <br> re.IGNORECASE|进行忽略大小写匹配；表达式如 [A-Z] 也会匹配小写字符。Unicode匹配（比如 Ü 匹配 ü）同样有用，除非设置了 re.ASCII 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 re.LOCALE 标记。这个相当于内联标记 (?i)|
re.L <br> re.LOCALE|由当前语言区域决定 \w, \W, \b, \B 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 "习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 (?L) 。|
re.M <br> re.MULTILINE|设置以后，样式字符 '^' 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 '$' 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，’^’ 匹配字符串头，'$' 匹配字符串尾。对应内联标记 (?m) |
re.S <br> re.DOTALL|让 '.' 特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.' 就匹配 除了 换行符的其他任意字符。对应内联标记 (?s) |
re.X <br> re.VERBOSE|这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 *?, (?: or (?P<…> 分组之内。当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。|

# 2.正则表达式对象

#### re.RegexObject

re.compile() 返回 RegexObject 对象

#### re.MatchObject

group() 返回被 RE 匹配的字符串:
- `start()`返回匹配开始的位置
- `end() 返回匹配结束的位置`
- `span()` 返回一个元组包含匹配 (开始,结束) 的位置

# 3.re模块内容


re模块|描述|
-|-|
re.compile(pattern, flags=0)|将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配|
re.search(pattern, string, flags=0)|扫描整个 字符串 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 None ； 注意这和找到一个零长度匹配是不同的|
re.match(pattern, string, flags=0)|如果 string 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 None ；注意它跟零长度匹配是不同的|
re.fullmatch(pattern, string, flags=0)|如果整个 string 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 None ；注意这跟零长度匹配是不同的|
re.split(pattern, string, maxsplit=0, flags=0)|用 pattern 分开 string 。 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素|
re.findall(pattern, string, flags=0)|对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里|
re.finditer(pattern, string, flags=0)|pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里|
re.sub(pattern, repl, string, count=0, flags=0)|返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。 如果样式没有找到，则不加改变地返回 string。 repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，\n 会被转换为一个换行符，\r 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 \& 会保持原样。 向后引用像是 \6 会用样式中第 6 组所匹配到的子字符串来替换|
re.subn(pattern, repl, string, count=0, flags=0)|行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数)|
re.escape(pattern)|转义 pattern 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配|
re.purge()|清除正则表达式缓存|

# 4.正则对象

编译后的正则表达式对象支持一下方法和属性

正则对象|描述|
-|-|
Pattern.search(string[, pos[, endpos]])|扫描整个 string 寻找第一个匹配的位置， 并返回一个相应的 匹配对象。如果没有匹配，就返回 None ；注意它和零长度匹配是不同的|
Pattern.match(string[, pos[, endpos]])|如果 string 的 开始位置 能够找到这个正则样式的任意个匹配，就返回一个相应的 匹配对象。如果不匹配，就返回 None ；注意它与零长度匹配是不同的|
Pattern.fullmatch(string[, pos[, endpos]])|如果整个 string 匹配这个正则表达式，就返回一个相应的 匹配对象 。 否则就返回 None ； 注意跟零长度匹配是不同的|
Pattern.split(string, maxsplit=0)|等价于 split() 函数，使用了编译后的样式|
Pattern.findall(string[, pos[, endpos]])|类似函数 findall() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()|
Pattern.finditer(string[, pos[, endpos]])|类似函数 finiter() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()|
Pattern.sub(repl, string, count=0)|等价于 sub() 函数，使用了编译后的样式|
Pattern.subn(repl, string, count=0)|等价于 subn() 函数，使用了编译后的样式|
Pattern.flags|正则匹配标记。这是可以传递给 compile() 的参数，任何 (?…) 内联标记，隐性标记比如 UNICODE 的结合|
Pattern.groups|捕获组合的数量|
Pattern.groupindex|映射由 (?P<id>) 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的|
Pattern.pattern|编译对象的原始样式字符串|

`注意`：通过 re.compile() 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。

# 5.匹配对象

匹配对象支持以下方法和属性

匹配对象|描述|
-|-|
Match.expand(template)|对 template 进行反斜杠转义替换并且返回，就像 sub() 方法中一样。转义如同 \n 被转换成合适的字符，数字引用(\1, \2)和命名组合(\g<1>, \g<name>) 替换为相应组合的内容|
Match.group([group1, ...])|返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）|
Match.__getitem__(g)|这个等价于 m.group(g)。这允许更方便的引用一个匹配|
Match.groups(default=None)|返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 default 参数用于不参与匹配的情况，默认为 None|
Match.groupdict(default=None)|返回一个字典，包含了所有的 命名 子组。key就是组名。 default 参数用于不参与匹配的组合；默认为 None。 |
Match.start([group]) <br> Match.end([group])|返回 group 匹配到的字串的开始和结束标号。group 默认为0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1 。对于一个匹配对象 m， 和一个未参与匹配的组 g ，组 g (等价于 m.group(g))产生的匹配是|
Match.span([group])|对于一个匹配 m ， 返回一个二元组 (m.start(group), m.end(group)) 。 注意如果 group 没有在这个匹配中，就返回 (-1, -1) 。group 默认为0，就是整个匹配|
Match.pos|pos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎开始在字符串搜索一个匹配的索引位置|
Match.endpos|endpos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎停止在字符串搜索一个匹配的索引位置|
Match.lastindex|捕获组的最后一个匹配的整数索引值，或者 None 如果没有匹配产生的话。比如，对于字符串 'ab'，表达式 (a)b, ((a)(b)), 和 ((ab)) 将得到 lastindex == 1 ， 而 (a)(b) 会得到 lastindex == 2 |
Match.lastgroup|最后一个匹配的命名组名字，或者 None 如果没有产生匹配的话|
Match.re|返回产生这个实例的 正则对象 ， 这个实例是由 正则对象的 match() 或 search() 方法产生的|
Match.string|传递到 match() 或 search() 的字符串|

# 6.正则前缀r

以r或R开头的python中的字符串表示（非转义的）[原始字符串 传送门](/python/2019/06/17/python-3.html#2%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2 "/python/2019/06/17/python-3.html#2%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2")请查看[字符串章节](/python/2019/06/17/python-3.html "/python/2019/06/17/python-3.html")原始字符串定义

当我们匹配一个路径时`c:\\test`，假如需要匹配文本中`\`,那么使用编程语言表示的正则表达式里将需要4个反斜杠"\\"：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。

```python
#添加r
ret = re.match(r"c:\\test",'c:\\test').group()
>>> ret
'c:\\test'

#不添加r
ret = re.match("c:\\\\test",'c:\\test').group()
>>> ret
'c:\\test'
```
`注意：在正则中添加r前缀一般用于路径匹配较多`

# 7.判断是否匹配成功

`match()`方法判断是否匹配，如果匹配成功，返回一个`Match`对象，否则返回`None`

```python
#验证手机号
test = "15525341345"
if re.match('^1(3|4|5|7|8)\d{9}$',test):
    print('ok')
else:
    print('failed')
```

# 8.获取正则匹配内容

```python
s = '123asdf298adsfa'
ret = re.findall('(\d+)[a-z]+(\d+)',s)
>>> ret
[('123', '298')]
```

####使用match获取匹配内容

```python
s = '123asdf298adsfa'
ret = re.match('(\d+)[a-z]+(\d+)',s).group(1,2)
>>> ret
('010', '12345')
```

# 9.贪婪与非贪婪

`贪婪`与`非贪婪`模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配, python中默认是`贪婪模式`

`非贪婪`在数量词后面添加一个`?`

```python
# 贪婪
s = 'python 111java678php'
r = re.findall('[a-z]{3,6}',s)
>>> r
['python', 'java', 'php']

# 非贪婪 
s = 'python 111java678php'
r = re.findall('[a-z]{3,6}?',s)
>>> r
['pyt', 'hon', 'jav', 'php']
```

# 10.正则替换

```python
s = 'hello'
r = re.sub('ll','yy',s)
>>> r
'heyyo'
```














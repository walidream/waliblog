---
layout: post
title: nginx 正向，反向代理配置(14)  #标题
tagline: nginx 正向代理，反向代理详解
category: nginx      #分类
author: wali    #作者
tag: nginx     #标签
ghurl:        #github url
ghurl_zip:    #github zip下载
comments: true

post_nav: ["1.代理分类","2.正向代理","3.反向代理","4.nginx支持的代理协议","5.配置模块","6.反向代理配置","7.正向代理配置","8.添加代理常用配置项"]
group_tag: nginx教程
---

nginx代理服务，所谓的代理简单理解就是代为办理。生活中常见的代理（代理理财、代理收货等等）。在没有nginx作为代理服务时，客户端直接发送请求，服务端直接响应请求

![ssl]({{ site.url }}/assets/image/nginx/nginx_15.jpg?1234)

当出现nginx代理服务时，客户端所有的请求由nginx接收在转发给服务端，服务单响应给nginx在有nginx响应给客户端。

![ssl]({{ site.url }}/assets/image/nginx/nginx_16.jpg?1234)

# 1.代理分类

代理分类按照应用场景模式分为两类，一个是`正向代理`，正向代理代理的对象是客户端，为客户端提供服务，另一个是`反向代理`，反向代理代理的对象服务端，为服务端提供服务。

正向代理和反向代理区分是看nginx代理的是客户端还是服务端，如果nginx代理的是客户端就是正向代理，代理的是服务端就是反向代理。

# 2.正向代理

正向代理也就是代理，他的工作原理就像一个跳板，简单的说，我访问不了google.com，但是我能访问一个代理服务器A，A能访问google.com，于是我先连上代理服务器A，告诉他我需要google.com的内容，A就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。

结论就是，正向代理是一个位于客户端和原始服务器(origin server)之间的服务器。为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。

![ssl]({{ site.url }}/assets/image/nginx/nginx_17.png?1234)

# 3.反向代理

举个例子，比如我想访问 http://www.test.com/readme，但www.test.com上并不存在readme页面，于是他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里所提到的 www.test.com 这个域名对应的服务器就设置了反向代理功能。

结论就是，反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。

![ssl]({{ site.url }}/assets/image/nginx/nginx_18.png?1234)

# 4.nginx支持的代理协议

nginx支持非常多的代理协议，支持http、https、websocket、GRPC、ICMP/POP/IMAP、RTMP。http是web服务中常用超文本协议，https是当前主流的一个加密协议，websocket是在http1.1版本之上
客户端与服务端常连接通信协议，GRPC是GO开发中远程过程调用协议，ICMP/POP/IMAP是邮件收发协议，RTMP是应用流媒体服务协议(直播)。

![ssl]({{ site.url }}/assets/image/nginx/nginx_19.jpg)

### 常见的nginx作为反向代理支持协议

![ssl]({{ site.url }}/assets/image/nginx/nginx_21.jpg)

### 反向代理模式与nginx代理模块

![ssl]({{ site.url }}/assets/image/nginx/nginx_20.jpg)

### 常见的nginx作为正向代理支持协议

![ssl]({{ site.url }}/assets/image/nginx/nginx_22.jpg)

# 5.配置模块

### proxy_pass

proxy_pass配置项属于`ngx_http_proxy_module`模块[传送门](http://nginx.org/en/docs/http/ngx_http_proxy_module.html "http://nginx.org/en/docs/http/ngx_http_proxy_module.html"){:target="_blank"}

```nginx
Syntax:	proxy_pass URL;
Default: —
Context: location, if in location, limit_except
```

# 6.反向代理配置

服务目录如下
```txt
/opt/app  #应用目录
   |--code1
     |--index.html
   |--code2
     |--testproxy.html

/etc/nginx/conf.d/ #配置目录
   |
   |--fs_proxy.conf
   |--realserver.conf
```

#### index.html

```html
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<h1>瓦力博客</h1>
</body>
</html>
```

#### testproxy.html

```html
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<h1>代理测试页面</h1>
</body>
</html>
```

#### fs_proxy.conf

```nginx
server {
    listen       80; 
    server_name  localhost;
 
    location / { 
        root   /opt/app/code1;
        index  index.html index.htm;
    }      

    location ~ /testproxy.html$ {  #设置代理
        proxy_pass http://127.0.0.1:9000;
    }
}
```

#### realserver.conf

```nginx
server {
    listen       9000; 
    server_name  localhost;
 
    location / { 
        root   /opt/app/code2;
        index  index.html index.htm;
    }      
}
```

#### 检测重启nginx

	nginx -tc /etc/nginx/nginx.conf  #检测语法

	nginx -s reload -c /etc/nginx/nginx.conf #重启

上面创建了两个应用分别为`code1`和`code2`。code1分配的是80端口，code2分配的9000端口，默认80端口可以在公网访问，而9000端口不能
在公网上访问，code1的nginx配置为`fs_proxy.conf`，code2的nginx配置为`realserver.conf`。通过nginx反向代理设置我们就
可以在公网上访问code2的应用，访问地址`http://walidream.com/testproxy.html`。通过fs_proxy.conf配置匹配`/testproxy.html$`

```nginx
location ~ /testproxy.html$ {  #设置代理
	proxy_pass http://127.0.0.1:9000;
}
```

![ssl]({{ site.url }}/assets/image/nginx/nginx_23.png)
  
# 7.正向代理配置

测试正向代理需要两台服务器，小菜呢刚好有两台服务器就来玩一玩。server1: `www.walidream.com`，server2:`www.yagm.xin`。

### server1服务目录

```txt
/etc/nginx/conf.d/  #配置
    |
	|--zx_proxy.conf
```

#### zx_proxy.conf(server1服务器)

```nginx
server {
    listen       80; 
    server_name  localhost;
	
    resolver 8.8.8.8;
    location / { 
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        proxy_pass http://yagm.xin;
    }      
}
```

这里面需要注意的是`resolver`dns解析，因为正向代理的dns解析在代理上面。

### server2服务目录

```txt
/home/app #应用
    |
	|--index.html
	
/etc/nginx/conf.d/  #配置
    |
	|--admin.conf
```

#### index.html(server2服务器)

```html
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<h1>洋洋的一米阳光</h1>
</body>
</html>
```

#### admin.conf(server2服务器)

```nginx
server {
    listen       80; 
    server_name  localhost;
	
    location / { 
        if ( $http_x_forwarded_for !~* "^99\.99\.99\.99" ) { 
            return 403;
        }
        root   /home/app;
        index  index.html index.htm;
    }      
}
```

#### 检测重启nginx

	nginx -tc /etc/nginx/nginx.conf  #检测语法

	nginx -s reload -c /etc/nginx/nginx.conf #重启
	
上面两个应用分别在两个服务器上，server1: `www.walidream.com`，server2:`www.yagm.xin`。server2服务器只允许server1服务器来访问，其他访问拒绝。通过在server1
服务器上配置nginx的正向代理来访问server2上面的服务

![ssl]({{ site.url }}/assets/image/nginx/nginx_24.png)
	
> 特别注意

上面配置语法中的IP`99.99.99.99`不是server2服务器的公网ip。小菜用的服务器是阿里云的服务器，但是这个里面`$http_x_forwarded_for`是代理做转发的ip。第一次填写成
阿里云服务器的公网IP返回总是403。后面查看日志时，发现日志中打印的`http_x_forwarded_for`的IP值和填写的阿里云公网IP不一样，小菜呢猜想，虽然用阿里云给的公网IP
能够访问的到阿里云服务器。但是不能保证阿里云没有给自己的服务器做代理。小菜将`99.99.99.99`换成了日志中的`$http_x_forwarded_for`的值，然后就ok了。

访问http://www.walidream.com就可以看到http://www.yagm.xin服务器上的内容

![ssl]({{ site.url }}/assets/image/nginx/nginx_25.jpg)

# 8.添加代理常用配置项

下面介绍的配置项都属于`ngx_http_proxy_module`模块[传送门](http://nginx.org/en/docs/http/ngx_http_proxy_module.html "http://nginx.org/en/docs/http/ngx_http_proxy_module.html"){:target="_blank"}

### 1.proxy_redirect

```nginx
Syntax:	proxy_redirect default;
	proxy_redirect off;
	proxy_redirect redirect replacement;
Default: proxy_redirect default;
Context: http, server, location
```

### 2.proxy_set_header

```nginx
Syntax: proxy_set_header field value;
Default:proxy_set_header Host $proxy_host;
	proxy_set_header Connection close;
Context: http, server, location
```

### 3.proxy_connect_timeout

```nginx
Syntax:	proxy_connect_timeout time;
Default: proxy_connect_timeout 60s;
Context: http, server, location
```

### 4.proxy_send_timeout

```nginx
Syntax:	proxy_send_timeout time;
Default: proxy_send_timeout 60s;
Context: http, server, location
```

### 5.proxy_read_timeout

```nginx
Syntax:	proxy_read_timeout time;
Default: proxy_read_timeout 60s;
Context: http, server, location
```

### 6.proxy_buffer_size

```nginx
Syntax:	proxy_buffer_size size;
Default: proxy_buffer_size 4k|8k;
Context: http, server, location
```

### 7.proxy_buffering

```nginx
Syntax:	proxy_buffering on | off;
Default: proxy_buffering on;
Context: http, server, location
```

### 8.proxy_buffers

```nginx
Syntax:	proxy_buffers number size;
Default: proxy_buffers 8 4k|8k;
Context: http, server, location
```

### 9.proxy_busy_buffers_size

```nginx
Syntax:	proxy_busy_buffers_size size;
Default: proxy_busy_buffers_size 8k|16k;
Context: http, server, location
```

### 10.proxy_max_temp_file_size

```nginx
Syntax:	proxy_max_temp_file_size size;
Default: proxy_max_temp_file_size 1024m;
Context: http, server, location
```

上面的配置项都是在设置代理时常用到的配置，小菜建议将常用的配置放在一个文件里。

	vim /etc/nginx/proxy_pass
	
创建好proxy_pass文件之后，将下面内容拷贝进去。
	
```nginx
#proxy_pass 代理常用配置

proxy_redirect default;

proxy_set_header Host $http_host;
proxy_set_header X-Real-IP $remote_addr;

proxy_connect_timeout 30;
proxy_send_timeout 60;
proxy_read_timeout 60;

proxy_buffer_size 32k;
proxy_buffering on;
proxy_buffers 4 128k;
proxy_busy_buffers_size 256k;
proxy_max_temp_file_size 256k;
```

在配置代理时，只需要将文件内容导入nginx配置就成了。

```nginx
location / {
	proxy_pass http://127.0.0.1:8080;
	include proxy_params;  #将配置文件导入
}
```
































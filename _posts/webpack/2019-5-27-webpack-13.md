---
layout: post
title: webpack 打包分析,Preloading,Prefetching(13)
tagline: webpack教程
category: webpack      #分类
author: wali    #作者
tag: webpack     #标签
ghurl:      #github url
ghurl_zip:  #github zip下载
comments: true
post_nav: []
group_tag: webpack4.x 教程
---

本小节主要给大家介绍如何提高代码的性能?我们从打包工具入手，然后到预提模块(Preloading)，预加载模块(Prefetching)。

# 1.打包分析

- [官方提供的分析工具](https://github.com/webpack/analyse "https://github.com/webpack/analyse"){:target="_blank"}
- [webpack-chart](https://alexkuz.github.io/webpack-chart/ "https://alexkuz.github.io/webpack-chart/"){:target="_blank"}：webpack stats 可交互饼图
- [webpack-visualizer](https://chrisbateman.github.io/webpack-visualizer/ "https://chrisbateman.github.io/webpack-visualizer/"){:target="_blank"} :可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的
- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer "https://github.com/webpack-contrib/webpack-bundle-analyzer"){:target="_blank"} :一个 plugin 和 CLI 工具，它将 bundle 内容展示为便捷的、交互式、可缩放的树状图形式
- [webpack bundle optimize helper](https://webpack.jakoblind.no/optimize/ "https://webpack.jakoblind.no/optimize/"){:target="_blank"} :此工具会分析你的 bundle，并为你提供可操作的改进措施建议，以减少 bundle 体积大小。

打包分析是指当webpack对我们的代码打包过后，我们使用分析工具对打包后的文件进行一定的分析，帮助我们看打包后的代码有没有继续提升的空间。

#### 生成stats.json

您可以通过运行`webpack --profile --json> stats.json`为此工具生成所需的JSON文件

#### package.json

```diff
{
 "scripts": {
    "dev": "npx webpack-dev-server --config webpack.config.js --mode=development --colors",
    "prod": "npx webpack --config webpack.config.js --mode=production",
    "build": "npx webpack --config webpack.config.js --mode=development --colors"
+    "analyse": "npx webpack --profile --json> stats.json --config webpack.config.js --mode=development --colors"
  },
}
```

#### 运行webpack

```
yarn run analyse
```

![ssl](http://walidream.com:9999/blogImage/webpack/webpack_25.png)

在我们的项目下面生成了一个`stats.json`文件，将`stats.json`文件上传到官方分析工具中就可以了。

# 2.使用webpackBundleAnalyzer

#### 安装webpack-bundle-analyzer

```
yarn add -D webpack-bundle-analyzer
```

#### webpack.config.js

```diff
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

![ssl](http://walidream.com:9999/blogImage/webpack/webpack_26.png)

# 3.prefetch

- [Preloading官方](https://webpack.docschina.org/guides/code-splitting/#%E9%A2%84%E5%8F%96-%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97-prefetch-preload-module- "https://webpack.docschina.org/guides/code-splitting/#%E9%A2%84%E5%8F%96-%E9%A2%84%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97-prefetch-preload-module-"){:target="_blank"}

在声明import时，使用下面这些内置指令，可以让webpack输出`resource hint（资源提示）`来告知浏览器：

- prefetch(预获取): 将来某些导航下可能需要的资源
- preload(预加载)：当前导航下可能需要资源

上面我是看中文的文档，有英文能力的小伙伴可以看英文，这样理解比较准确。小菜本想在这里说说个人理解，但是写出来后，感觉语言描述的不是很清楚，那还是用代码来演示吧。

```javascript
splitChunks: {
    chunks: 'all'
}
```
webpack官方默认`chunks:async`，官方为什么要默认`chunks:async`呢？当我们在引入loadsh，jquery库时，如果配置`chunks: 'all'`，那么肯定会帮助我们把`loadsh`、`jquery`单独拆分开来，但是这样做并不能提升首页的代码性能，原因是在浏览器第一次加载时，还是需要我们加载`loadsh`、`jquery`库，只有当我们的代码第二次加载时，浏览器才会从缓存中去找，提高我们第二次页面加载访问速度。webpack是想让我们第一次加载时，访问速度就是最快。举个列子

#### src/index.js
























I"<p>loadsh是一个非常实用的工具库，小菜在见到这个工具库就被深深的吸引了。有了这个工具库大部分的处理就不需要自己写工具了，想想就美滋滋。官方的网站<a href="https://www.lodashjs.com/" title="https://www.lodashjs.com/" target="_blank">https://www.lodashjs.com/</a>，这个是有中文翻译的<a href="http://lodash.think2011.net/chunk" title="http://lodash.think2011.net/chunk" target="_blank">http://lodash.think2011.net/chunk</a>，小菜这篇博客只是针对自己能够快速查阅所做的一个记录。</p>

<h1 id="1array数组">1.Array(数组)</h1>

<blockquote>
  <p>适用于数组类型，比如填充数据、查找元素、数组分片等操作</p>
</blockquote>

<h3 id="_chunkarray-size0">_.chunk(array, [size=0])</h3>

<blockquote>
  <p>将数组拆分成多个 size 长度的块，并组成一个新数组。 如果数组无法被分割成全部等长的块，那么最后剩余的元素将组成一个块。</p>
</blockquote>

<h3 id="_compactarray">_.compact(array)</h3>

<blockquote>
  <p>创建一个移除了所有假值的数组。例如：false、null、 0、”“、undefined， 以及NaN 都是 “假值”.</p>
</blockquote>

<h3 id="_concatarray-values">_.concat(array, [values])</h3>

<blockquote>
  <p>创建一个用任何数组 或 值连接的新数组</p>
</blockquote>

<h3 id="_differencearray-values">_.difference(array, [values])</h3>

<blockquote>
  <p>创建一个差异化后的数组，不包括使用 SameValueZero 方法提供的数组。</p>
</blockquote>

<h3 id="differencebyarray-values-iterateeidentity"><em>.differenceBy(array, [values], [iteratee=</em>.identity])</h3>

<blockquote>
  <p>这个方法类似 _.difference，除了它接受一个 iteratee 调用每一个数组和值。iteratee 会传入一个参数：(value)</p>
</blockquote>

<h3 id="_differencewitharray-values-comparator">_.differenceWith(array, [values], [comparator])</h3>

<blockquote>
  <p>这个方法类似 _.difference，除了它接受一个 comparator 调用每一个数组元素的值。 comparator 会传入2个参数：(arrVal, othVal)。</p>
</blockquote>

<h3 id="_droparray-n1">_.drop(array, [n=1])</h3>

<blockquote>
  <p>裁剪数组中的前 N 个数组，返回剩余的部分。</p>
</blockquote>

<h3 id="_droprightarray-n1">_.dropRight(array, [n=1])</h3>

<blockquote>
  <p>从右边开始裁剪数组中的 N 个数组，返回剩余的部分。</p>
</blockquote>

<h3 id="droprighwhilearray-predicateidentity"><em>.dropRighWhile(array, [predicate=</em>.identity])</h3>

<blockquote>
  <p>从右边开始裁剪数组，起点从 predicate 返回假值开始。predicate 会传入3个参数：(value, index, array)。</p>
</blockquote>

<h3 id="dropwhilearray-predicateidentity"><em>.dropWhile(array, [predicate=</em>.identity])</h3>

<blockquote>
  <p>裁剪数组，起点从 predicate 返回假值开始。predicate 会传入3个参数：(value, index, array)。</p>
</blockquote>

<h3 id="_fillarray-value-start0-endarraylength">_.fill(array, value, [start=0], [end=array.length])</h3>

<blockquote>
  <p>指定 值 填充数组，从 start 到 end 的位置，但不包括 end 本身的位置。</p>
</blockquote>

<h3 id="findindexarray-predicateidentity"><em>findIndex(array, [predicate=</em>.identity])</h3>

<blockquote>
  <p>这个方法类似 _.find。除了它返回最先通过 predicate 判断为真值的元素的 index ，而不是元素本身。</p>
</blockquote>

<h3 id="_findlastindex">_.findLastIndex</h3>

<blockquote>
  <p>这个方式类似 _.findIndex ， 不过它是从右到左的</p>
</blockquote>

<h3 id="_first-head">_.first-&gt;head</h3>

<blockquote>
  <p>获取数组第一个元素</p>
</blockquote>

<h3 id="_flatten">_.flatten</h3>

<blockquote>
  <p>向上一级展平数组嵌套</p>
</blockquote>

<h3 id="_flattendeep">_.flattenDeep</h3>

<blockquote>
  <p>递归展平 数组.</p>
</blockquote>

<h3 id="_flattendepth">_.flattenDepth</h3>

<blockquote>
  <p>根据 depth 递归展平 数组 的层级</p>
</blockquote>

<h3 id="_frompairs">_.fromPairs</h3>

<blockquote>
  <p>反向版 _.toPairs，这个方法返回一个由键值对构成的对象</p>
</blockquote>

<h3 id="_head">_.head</h3>

<blockquote>
  <p>获得数组的首个元素</p>
</blockquote>

<h3 id="_indexof">_.indexOf</h3>

<blockquote>
  <p>根据 value 使用 SameValueZero 等值比较返回数组中首次匹配的 index， 如果 fromIndex 为负值，将从数组尾端索引进行匹配，如果将 fromIndex 设置为 true，将使用更快的二进制检索机制。</p>
</blockquote>

<h3 id="_initial">_.initial</h3>

<blockquote>
  <p>获取数组中除了最后一个元素之外的所有元素</p>
</blockquote>

<h3 id="_intersection">_.intersection</h3>

<blockquote>
  <p>创建一个包含所有使用 SameValueZero 进行等值比较后筛选的唯一值数组。</p>
</blockquote>

<h3 id="_intersectionby">_.intersectionBy</h3>

<blockquote>
  <p>这个方法类似 _.intersection，除了它接受一个 iteratee 调用每一个数组和值。iteratee 会传入一个参数：(value)</p>
</blockquote>

<h3 id="_intersectionwith">_.intersectionWith</h3>

<blockquote>
  <p>这个方法类似 _.intersection，除了它接受一个 comparator 调用每一个数组和值。iteratee 会传入2个参数：((arrVal, othVal)</p>
</blockquote>

<h3 id="_join">_.join</h3>

<blockquote>
  <p>将数组中的所有元素转换为由 separator 分隔的字符串。</p>
</blockquote>

<h3 id="_last">_.last</h3>

<blockquote>
  <p>获取数组中的最后一个元素</p>
</blockquote>

<h3 id="_lastindexof">_.lastIndexOf</h3>

<blockquote>
  <p>这个方法类似 _.indexOf，除了它是从右到左遍历元素的。 这个方法类似 _.indexOf except that it iterates over elements of array from right to left.</p>
</blockquote>

<h3 id="_nth">_.nth</h3>

<blockquote>
  <p>获取数组索引n处的元素。如果n为负数，则返回结尾的第n个元素。</p>
</blockquote>

<h3 id="_pull">_.pull</h3>

<blockquote>
  <p>移除所有经过 SameValueZero 等值比较为 true 的元素</p>
</blockquote>

<h3 id="_pullall">_.pullAll</h3>

<blockquote>
  <p>这个方式类似 _.pull，除了它接受数组形式的一系列值。</p>
</blockquote>

<h3 id="_pullallby">_.pullAllBy</h3>

<blockquote>
  <p>这个方法类似 _.pullAll，除了它接受一个 comparator 调用每一个数组元素的值。 comparator 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_pullallwith">_.pullAllWith</h3>

<blockquote>
  <p>此方法类似于_.pullAll，除了它接受比较器，该比较器被调用以将数组元素与值进行比较。使用两个参数调用比较器：（arrVal，othVal）。</p>
</blockquote>

<h3 id="_pullat">_.pullAt</h3>

<blockquote>
  <p>根据给的 indexes 移除对应的数组元素并返回被移除的元素。</p>
</blockquote>

<h3 id="_remove">_.remove</h3>

<blockquote>
  <p>移除经过 predicate 处理为真值的元素，并返回被移除的元素。predicate 会传入3个参数：(value, index, array)</p>
</blockquote>

<h3 id="_reverse">_.reverse</h3>

<blockquote>
  <p>数组反转</p>
</blockquote>

<h3 id="_slice">_.slice</h3>

<blockquote>
  <p>创建一个裁剪后的数组，从 start 到 end 的位置，但不包括 end 本身的位置。</p>
</blockquote>

<h3 id="_sortedindex">_.sortedIndex</h3>

<blockquote>
  <p>使用二进制的方式检索来决定 value 应该插入在数组中位置。它的 index 应该尽可能的小以保证数组的排序。</p>
</blockquote>

<h3 id="_sortedindexby">_.sortedIndexBy</h3>

<blockquote>
  <p>这个方法类似 _.sortedIndex，除了它接受一个 iteratee 调用每一个数组和值来计算排序。iteratee 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_sortedindexof">_.sortedIndexOf</h3>

<blockquote>
  <p>这个方法类似 _.indexOf，除了它是执行二进制来检索已经排序的数组的。</p>
</blockquote>

<h3 id="_sortedlastindex">_.sortedLastIndex</h3>

<blockquote>
  <p>这个方法类似 _.sortedIndex，除了它返回在 value 中尽可能大的 index 位置。</p>
</blockquote>

<h3 id="_sortedlastindexby">_.sortedLastIndexBy</h3>

<blockquote>
  <p>这个方法类似 _.sortedLastIndex，除了它接受一个 iteratee 调用每一个数组和值来计算排序。iteratee 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_sortedlastindexof">_.sortedLastIndexOf</h3>

<blockquote>
  <p>这个方法类似 _.lastIndexOf，除了它是执行二进制来检索已经排序的数组的。</p>
</blockquote>

<h3 id="_sorteduniq">_.sortedUniq</h3>

<blockquote>
  <p>这个方法类似 _.uniq，除了它会排序并优化数组。</p>
</blockquote>

<h3 id="_sorteduniqbyarray-iteratee">_.sortedUniqBy(array, [iteratee])</h3>

<blockquote>
  <p>这个方法类似 _.uniqBy，除了它接受一个 iteratee 调用每一个数组和值来排序并优化数组。</p>
</blockquote>

<h3 id="_tailarray">_.tail(array)</h3>

<blockquote>
  <p>获取数组中除了第一个元素的剩余数组</p>
</blockquote>

<h3 id="_takearray-n1">_.take(array, [n=1])</h3>

<blockquote>
  <p>从数组的起始元素开始提取 N 个元素。</p>
</blockquote>

<h3 id="_takerightarray-n1">_.takeRight(array, [n=1])</h3>

<blockquote>
  <p>从数组的结束元素开始提取 N 个数组</p>
</blockquote>

<h3 id="_takerightwhile">_.takeRightWhile</h3>

<blockquote>
  <p>从数组的最右边开始提取数组，直到 predicate 返回假值。predicate 会传入三个参数：(value, index, array)。</p>
</blockquote>

<h3 id="_takewhille">_.takeWhille</h3>

<blockquote>
  <p>从数组的开始提取数组，直到 predicate 返回假值。predicate 会传入三个参数：(value, index, array)。</p>
</blockquote>

<h3 id="_union">_.union</h3>

<blockquote>
  <p>创建顺序排列的唯一值组成的数组。所有值经过 SameValueZero 等值比较。</p>
</blockquote>

<h3 id="_unionby">_.unionBy</h3>

<blockquote>
  <p>这个方法类似 _.union，除了它接受一个 iteratee 调用每一个数组和值。iteratee 会传入一个参数：(value)</p>
</blockquote>

<h3 id="_unionwith">_.unionWith</h3>

<blockquote>
  <p>这个方法类似 _.union， 除了它接受一个 comparator 调用每一个数组元素的值。 comparator 会传入2个参数：(arrVal, othVal)。</p>
</blockquote>

<h3 id="_uniq">_.uniq</h3>

<blockquote>
  <p>创建一个不重复的数组副本。使用了 SameValueZero 等值比较。只有首次出现的元素才会被保留。</p>
</blockquote>

<h3 id="_uniqby">_.uniqBy</h3>

<blockquote>
  <p>这个方法类似 _.uniq，除了它接受一个 iteratee 调用每一个数组和值来计算唯一性。iteratee 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_uniqwith">_.uniqWith</h3>

<blockquote>
  <p>这个方法类似 _.uniq，除了它接受一个 comparator 来比较计算唯一性。 comparator 会传入2个参数：(arrVal, othVal)</p>
</blockquote>

<h3 id="_unzip">_.unzip</h3>

<blockquote>
  <p>这个方法类似 _.zip，除了它接收一个打包后的数组并且还原为打包前的状态。</p>
</blockquote>

<h3 id="_unziowith">_.unzioWith</h3>

<blockquote>
  <p>这个方法类似 _.unzip，除了它接受一个 iteratee 来决定如何重组解包后的数组。iteratee 会传入4个参数：(accumulator, value, index, group)。每组的第一个元素作为初始化的值</p>
</blockquote>

<h3 id="_without">_.without</h3>

<blockquote>
  <p>创建一个移除了所有提供的 values 的数组。使用了 SameValueZero 等值比较。</p>
</blockquote>

<h3 id="_xor">_.xor</h3>

<blockquote>
  <p>创建一个包含了所有唯一值的数组。使用了 symmetric difference 等值比较。</p>
</blockquote>

<h3 id="_xorby">_.xorBy</h3>

<blockquote>
  <p>这个方法类似 _.xor，除了它接受一个 iteratee 调用每一个数组和值。iteratee 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_xorwith">_.xorWith</h3>

<blockquote>
  <p>这个方法类似 _.xor，除了它接受一个 comparator 调用每一个数组元素的值。 comparator 会传入2个参数：(arrVal, othVal)。</p>
</blockquote>

<h3 id="_zip">_.zip</h3>

<blockquote>
  <p>创建一个打包所有元素后的数组。第一个元素包含所有提供数组的第一个元素，第二个包含所有提供数组的第二个元素，以此类推。</p>
</blockquote>

<h3 id="_zipobject">_.zipObject</h3>

<blockquote>
  <p>这个方法类似 _.fromPairs，除了它接受2个数组，一个作为属性名，一个作为属性值。</p>
</blockquote>

<h3 id="_zipobjectdeep">_.zipObjectDeep</h3>

<blockquote>
  <p>这个方法类似 _.zipObject，除了它支持属性路径。 This method is like _.zipObject except that it supports property paths.</p>
</blockquote>

<h3 id="_zipwith">_.zipWith</h3>

<blockquote>
  <p>这个方法类似 _.zip， 除了它接受一个 iteratee 决定如何重组值。 iteratee 会调用每一组元素。</p>
</blockquote>

<h1 id="2collection集合">2.Collection(集合)</h1>

<blockquote>
  <p>适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作</p>
</blockquote>

<h3 id="_countby">_.countBy</h3>

<blockquote>
  <p>创建一个组成对象，key是经过 iteratee 处理的集合的结果，value 是处理结果的次数。 iteratee 会传入一个参数：(value)。</p>
</blockquote>

<h3 id="_each-foreach">_.each-&gt;forEach</h3>

<blockquote>
  <p>迭代集合的元素并为每个元素调用iteratee。使用三个参数调用iteratee：（value，index | key，collection）。Iteratee函数可以通过显式返回false来提前退出迭代。</p>
</blockquote>

<h3 id="_each-foreachright">_.each-&gt;forEachRight</h3>

<blockquote>
  <p>此方法类似于_.forEach，只是它从右到左遍历集合的元素。</p>
</blockquote>

<h3 id="_every">_.every</h3>

<blockquote>
  <p>通过 predicate 检查集合中的元素是否都返回 真值，只要 predicate 返回一次假值，遍历就停止，并返回 false。 predicate 会传入3个参数：(value, index|key, collection)</p>
</blockquote>

<h3 id="_filter">_.filter</h3>

<blockquote>
  <p>遍历集合中的元素，筛选出一个经过 predicate 检查结果为真值的数组，predicate 会传入3个参数：(value, index|key, collection)。</p>
</blockquote>

<h3 id="_find">_.find</h3>

<blockquote>
  <p>遍历集合中的元素，返回最先经 predicate 检查为真值的元素。 predicate 会传入3个元素：(value, index|key, collection)。</p>
</blockquote>

<h3 id="_findlast">_.findLast</h3>

<blockquote>
  <p>这个方法类似 _.find，除了它是从右至左遍历集合的。</p>
</blockquote>

<h3 id="_flatmap">_.flatMap</h3>

<blockquote>
  <p>通过遍历iteratee运行集合中的每个元素并展平映射结果，创建一个展平的值数组。使用三个参数调用iteratee：（value，index | key，collection）。</p>
</blockquote>

<h3 id="_flatmapdeep">_.flatMapDeep</h3>

<blockquote>
  <p>方法就像_.flatMap，除了它递归地展平映射结果。</p>
</blockquote>

<h3 id="_flatmapdepth">_.flatMapDepth</h3>

<blockquote>
  <p>此方法类似于_.flatMap，除了它以递归方式将映射结果展平为深度时间。</p>
</blockquote>

<h3 id="_foreach">_.forEach</h3>

<blockquote>
  <p>调用 iteratee 遍历集合中的元素， iteratee 会传入3个参数：(value, index|key, collection)。 如果显式的返回 false ，iteratee 会提前退出</p>
</blockquote>

<h3 id="_foreachright">_.forEachRight</h3>

<blockquote>
  <p>这个方法类似 _.forEach，除了它是从右到左遍历的集合中的元素的。</p>
</blockquote>

<h3 id="_groupby">_.groupBy</h3>

<blockquote>
  <p>创建一个对象组成，key 是经 iteratee 处理的结果， value 是产生 key 的元素数组。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h3 id="_includes">_.includes</h3>

<blockquote>
  <p>检查 值 是否在 集合中，如果集合是字符串，那么检查 值 是否在字符串中。 其他情况用 SameValueZero 等值比较。 如果指定 fromIndex 是负数，从结尾开始检索。</p>
</blockquote>

<h3 id="_invokemap">_.invokeMap</h3>

<blockquote>
  <p>调用 path 的方法处理集合中的每一个元素，返回处理的数组。 如何附加的参数会传入到调用方法中。如果方法名是个函数，集合中的每个元素都会被调用到。</p>
</blockquote>

<h3 id="_keyby">_.keyBy</h3>

<blockquote>
  <p>创建一个对象组成。key 是经 iteratee 处理的结果，value 是产生key的元素。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h3 id="_map">_.map</h3>

<blockquote>
  <p>创建一个经过 iteratee 处理的集合中每一个元素的结果数组。 iteratee 会传入3个参数：(value, index|key, collection)。</p>
</blockquote>

<h3 id="_orderby">_.orderBy</h3>

<blockquote>
  <p>这个方法类似 _.sortBy，除了它允许指定 iteratees 结果如何排序。 如果没指定 orders，所有值以升序排序。 其他情况，指定 “desc” 降序，指定 “asc” 升序其对应值。</p>
</blockquote>

<h3 id="_partition">_.partition</h3>

<blockquote>
  <p>创建一个拆分为两部分的数组。 第一部分是 predicate 检查为真值的，第二部分是 predicate 检查为假值的。 predicate 会传入3个参数：(value, index|key, collection)。</p>
</blockquote>

<h3 id="_reduce">_.reduce</h3>

<blockquote>
  <p>通过 iteratee 遍历集合中的每个元素。 每次返回的值会作为下一次 iteratee 使用。 如果没有提供 accumulator，则集合中的第一个元素作为 accumulator。 iteratee 会传入4个参数：(accumulator, value, index|key, collection)。</p>
</blockquote>

<h3 id="_reduceright">_.reduceRight</h3>

<blockquote>
  <p>这个方法类似 _.reduce ，除了它是从右到左遍历的。</p>
</blockquote>

<h3 id="_reject">_.reject</h3>

<blockquote>
  <p>反向版 _.filter，这个方法返回 predicate 检查为非真值的元素。</p>
</blockquote>

<h3 id="_sample">_.sample</h3>

<blockquote>
  <p>从集合中随机获得元素</p>
</blockquote>

<h3 id="_samplesize">_.sampleSize</h3>

<blockquote>
  <p>获得从集合中随机获得 N 个元素 Gets n random elements from collection.</p>
</blockquote>

<h3 id="_shuffle">_.shuffle</h3>

<blockquote>
  <p>创建一个被打乱元素的集合。 使用了 Fisher-Yates shuffle 版本。</p>
</blockquote>

<h3 id="_size">_.size</h3>

<blockquote>
  <p>返回集合的长度或对象中可枚举属性的个数。</p>
</blockquote>

<h3 id="_some">_.some</h3>

<blockquote>
  <p>通过 predicate 检查集合中的元素是否存在任意真值的元素，只要 predicate 返回一次真值，遍历就停止，并返回 true。 predicate 会传入3个参数：(value, index|key, collection)。</p>
</blockquote>

<h3 id="_sortby">_.sortBy</h3>

<blockquote>
  <p>创建一个元素数组。 以 iteratee 处理的结果升序排序。 这个方法执行稳定排序，也就是说相同元素会保持原始排序。 iteratees 会传入1个参数：(value)。</p>
</blockquote>

<h1 id="3date日期">3.Date(日期)</h1>

<h3 id="_now">_.now</h3>

<blockquote>
  <p>获得 Unix 纪元(1970 1月1日 00:00:00 UTC) 直到现在的毫秒数。</p>
</blockquote>

<h1 id="4function函数">4.Function(函数)</h1>

<blockquote>
  <p>适用于函数类型，比如节流、延迟、缓存、设置钩子等操作</p>
</blockquote>

<h3 id="_after">_.after</h3>

<blockquote>
  <p>反向版 _.before。 这个方法创建一个新函数，当调用 N 次或者多次之后将触发 func 方法。</p>
</blockquote>

<h3 id="_ary">_.ary</h3>

<blockquote>
  <p>创建一个最多接受 N 个参数，忽略多余参数的方法。</p>
</blockquote>

<h3 id="_before">_.before</h3>

<blockquote>
  <p>创建一个调用 func 的函数。 调用次数不超过 N 次。 之后再调用这个函数，将返回最后一个调用的结果。</p>
</blockquote>

<h3 id="_bind">_.bind</h3>

<blockquote>
  <p>创建一个函数 func，这个函数的 this 会被绑定在 thisArg。 并且任何附加在 _.bind 的参数会被传入到这个绑定函数上。 这个 _.bind.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。</p>
</blockquote>

<h3 id="_bindkey">_.bindKey</h3>

<blockquote>
  <p>创建一个函数。 该方法绑定 object[key] 的方法。 任何附加在 _.bindKey 的参数会预设到该绑定函数上。</p>
</blockquote>

<h3 id="_curry">_.curry</h3>

<blockquote>
  <p>创建一个函数，该函数接收一个或多个 func 的参数。 当该函数被调用时,如果 func 所需要传递的所有参数都被提供，则直接返回 func 所执行的结果。 否则继续返回该函数并等待接收剩余的参数。 可以使用 func.length 强制需要累积的参数个数。</p>
</blockquote>

<h3 id="_curryright">_.curryRight</h3>

<blockquote>
  <p>这个方法类似 _.curry。 除了它接受参数的方式用 _.partialRight 代替了 _.partial。这个 _.curry.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。</p>
</blockquote>

<h3 id="_debounce">_.debounce</h3>

<blockquote>
  <p>创建一个防抖动函数。 该函数会在 wait 毫秒后调用 func 方法。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定延迟前后如何触发。 func 会传入最后一次传入的参数给防抖动函数。 随后调用的防抖动函数返回是最后一次 func 调用的结果。</p>
</blockquote>

<h3 id="_defer">_.defer</h3>

<blockquote>
  <p>延迟调用 func 直到当前堆栈清理完毕。 任何附加的参数会传入到 func。</p>
</blockquote>

<h3 id="_delay">_.delay</h3>

<blockquote>
  <p>延迟 wait 毫秒后调用 func。 任何附加的参数会传入到 func。</p>
</blockquote>

<h3 id="_flip">_.flip</h3>

<blockquote>
  <p>创建一个翻转接收参数的 func 函数。</p>
</blockquote>

<h3 id="_memoize">_.memoize</h3>

<blockquote>
  <p>创建一个会缓存 func 结果的函数。 如果提供了 resolver，就用 resolver 的返回值作为 key 缓存函数的结果。 默认情况下用第一个参数作为缓存的 key。 func 在调用时 this 会绑定在缓存函数上</p>
</blockquote>

<h3 id="_negate">_.negate</h3>

<blockquote>
  <p>创建一个对 func 结果 取反的函数。 用 predicate 对 func 检查的时候，this 绑定到创建的函数，并传入对应参数。</p>
</blockquote>

<h3 id="_once">_.once</h3>

<blockquote>
  <p>创建一个只能调用一次的函数。 重复调用返回第一次调用的结果。 func 调用时，this 绑定到创建的函数，并传入对应参数。</p>
</blockquote>

<h3 id="_overargs">_.overArgs</h3>

<blockquote>
  <p>创建一个函数，调用时func 参数会先一对一的改变。</p>
</blockquote>

<h3 id="_partial">_.partial</h3>

<blockquote>
  <p>创建一个函数。 该函数调用 func，并传入预设的参数。 这个方法类似 _.bind，除了它不会绑定 this。 这个 _.partial.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。</p>
</blockquote>

<h3 id="_partialright">_.partialRight</h3>

<blockquote>
  <p>这个函数类似 _.partial，除了它是从右到左预设参数的。 这个 .partialRight.placeholder 的值，默认是以 作为附加部分参数的占位符。</p>
</blockquote>

<h3 id="_rearg">_.rearg</h3>

<blockquote>
  <p>创建一个调用 func 的函数。 所传递的参数根据 indexes 调整到对应位置。 第一个 index 对应到第一个传参，第二个 index 对应到第二个传参，以此类推。</p>
</blockquote>

<h3 id="_rest">_.rest</h3>

<blockquote>
  <p>创建一个调用 func 的函数。 this 绑定到这个函数 并且 从 start 之后的参数都作为数组传入。</p>
</blockquote>

<h3 id="_spread">_.spread</h3>

<blockquote>
  <p>创建一个调用 func 的函数。 this 绑定到这个函数上。 把参数作为数组传入，类似于 Function#apply</p>
</blockquote>

<h3 id="_throttle">_.throttle</h3>

<blockquote>
  <p>创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果。</p>
</blockquote>

<h3 id="_unary">_.unary</h3>

<blockquote>
  <p>创建一个最多接受一个参数的函数，忽略多余的参数。</p>
</blockquote>

<h3 id="_wrap">_.wrap</h3>

<blockquote>
  <p>创建一个函数。提供的 value 包装在 wrapper 函数的第一个参数里。 任何附加的参数都提供给 wrapper 函数。 被调用时 this 绑定在创建的函数上。</p>
</blockquote>

<h1 id="5lang">5.Lang</h1>

<blockquote>
  <p>普遍适用于各种类型，常用于执行类型判断和类型转换</p>
</blockquote>

<h3 id="_castarray">_.castArray</h3>

<blockquote>
  <p>如果 value 不是数组, 那么强制转为数组</p>
</blockquote>

<h3 id="_clone">_.clone</h3>

<blockquote>
  <p>创建一个 value 的浅拷贝。</p>
</blockquote>

<h3 id="_clonedeep">_.cloneDeep</h3>

<blockquote>
  <p>这个方法类似 _.clone，除了它会递归拷贝 value。</p>
</blockquote>

<h3 id="_clonedeepwith">_.cloneDeepWith</h3>

<blockquote>
  <p>这个方法类似 _.cloneWith，除了它会递归拷贝 value。</p>
</blockquote>

<h3 id="_clonewith">_.cloneWith</h3>

<blockquote>
  <p>这个方法类似 _.clone，除了它接受一个 customizer 定制返回的拷贝值。 如果 customizer 返回 undefined 将会拷贝处理方法代替。 customizer 会传入5个参数：(value [, index|key, object, stack])</p>
</blockquote>

<h3 id="_conformsto">_.conformsTo</h3>

<blockquote>
  <p>通过使用object的相应属性值调用source的谓词属性来检查对象是否符合源。</p>
</blockquote>

<h3 id="_eq">_.eq</h3>

<blockquote>
  <p>执行 SameValueZero 比较两者的值确定它们是否相等。</p>
</blockquote>

<h3 id="_gt">_.gt</h3>

<blockquote>
  <p>检查 value 是否大于 other</p>
</blockquote>

<h3 id="_gte">_.gte</h3>

<blockquote>
  <p>检查 value 是否大于等于 other</p>
</blockquote>

<h3 id="_isarguments">_.isArguments</h3>

<blockquote>
  <p>检查 value 是否是 类 arguments 对象。</p>
</blockquote>

<h3 id="_isarray">_.isArray</h3>

<blockquote>
  <p>检查 value 是否是 Array 类对象。</p>
</blockquote>

<h3 id="_isarraybuffer">_.isArrayBuffer</h3>

<blockquote>
  <p>检查 value 是否是 ArrayBuffer 对象。</p>
</blockquote>

<h3 id="_isarraylike">_.isArrayLike</h3>

<blockquote>
  <p>检查 value 是否是类数组。 如果是类数组的话，应该不是一个函数，而且 value.length 是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER</p>
</blockquote>

<h3 id="_isarraylikeobject">_.isArrayLikeObject</h3>

<blockquote>
  <p>这个方法类似 _.isArrayLike，除了它还检查值是否是个对象。</p>
</blockquote>

<h3 id="_isboolean">_.isBoolean</h3>

<blockquote>
  <p>检查 value 是否是原始 boolean 类型或者对象。</p>
</blockquote>

<h3 id="_isbuffer">_.isBuffer</h3>

<blockquote>
  <p>检查 value 是否是个 buffer</p>
</blockquote>

<h3 id="_isdate">_.isDate</h3>

<blockquote>
  <p>检查 value 是否是 Date 类型</p>
</blockquote>

<h3 id="_iselement">_.isElement</h3>

<blockquote>
  <p>检查 value 是否是可能是 DOM 元素</p>
</blockquote>

<h3 id="_isempty">_.isEmpty</h3>

<blockquote>
  <p>检查 value 是否为空。 判断的依据是除非是有枚举属性的对象，length 大于 0 的 arguments object, array, string 或类jquery选择器。</p>
</blockquote>

<h3 id="_isequal">_.isEqual</h3>

<blockquote>
  <p>执行深比较来决定两者的值是否相等。</p>
</blockquote>

<h3 id="_isequalwith">_.isEqualWith</h3>

<blockquote>
  <p>这个方法类似 _.isEqual。 除了它接受一个 customizer 定制比较值。 如果 customizer 返回 undefined 将会比较处理方法代替。 customizer 会传入7个参数：(objValue, othValue [, index|key, object, other, stack])</p>
</blockquote>

<h3 id="_iserror">_.isError</h3>

<blockquote>
  <p>检查 value 是否是 Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, 或 URIError object.</p>
</blockquote>

<h3 id="_isfinite">_.isFinite</h3>

<blockquote>
  <p>检查 value 是否是原始 finite number。</p>
</blockquote>

<h3 id="_isfunction">_.isFunction</h3>

<blockquote>
  <p>检查 value 是否是 Function 对象。</p>
</blockquote>

<h3 id="_isinteger">_.isInteger</h3>

<blockquote>
  <p>检查 value 是否是整数。</p>
</blockquote>

<h3 id="_islength">_.isLength</h3>

<blockquote>
  <p>检查 value 是否是有效长度</p>
</blockquote>

<h3 id="_ismap">_.isMap</h3>

<blockquote>
  <p>检查 value 是否是个 Map 对象</p>
</blockquote>

<h3 id="_ismatch">_.isMatch</h3>

<blockquote>
  <p>执行一个深比较来确定object 是否包含有 source 的属性值。</p>
</blockquote>

<h3 id="_ismatchwith">_.isMatchWith</h3>

<blockquote>
  <p>这个方法类似 _.isMatch。 除了它接受一个 customizer 定制比较的值。 如果 customizer 返回 undefined 将会比较处理方法代替。 customizer 会传入5个参数：(objValue, srcValue, index|key, object, source)</p>
</blockquote>

<h3 id="_isnan">_.isNaN</h3>

<blockquote>
  <p>检查 value 是否是 NaN.</p>
</blockquote>

<h3 id="_isnative">_.isNative</h3>

<blockquote>
  <p>检查 value 是否是原生函数</p>
</blockquote>

<h3 id="_isnil">_.isNil</h3>

<blockquote>
  <p>检查 value 是否是 null 或者 undefined。</p>
</blockquote>

<h3 id="_isnull">_.isNull</h3>

<blockquote>
  <p>检查 value 是否是 null.</p>
</blockquote>

<h3 id="_isnumber">_.isNumber</h3>

<blockquote>
  <p>检查 value 是否是原始数值型 或者 对象。</p>
</blockquote>

<h3 id="_isobject">_.isObject</h3>

<blockquote>
  <p>检查 value 是否是 Object 的 language type。 (例如： arrays, functions, objects, regexes, new Number(0), 以及 new String(‘’))</p>
</blockquote>

<h3 id="_isobjectlike">_.isObjectLike</h3>

<blockquote>
  <p>检查 value 是否是 类对象。 类对象应该不是 null 以及 typeof 的结果是 “object”。</p>
</blockquote>

<h3 id="_isplainobject">_.isPlainObject</h3>

<blockquote>
  <p>检查 value 是否是普通对象。 也就是说该对象由 Object 构造函数创建或者 [[Prototype]] 为空。</p>
</blockquote>

<h3 id="_isregexp">_.isRegExp</h3>

<blockquote>
  <p>检查 value 是否是 RegExp 对象</p>
</blockquote>

<h3 id="_issafeinteger">_.isSafeInteger</h3>

<blockquote>
  <p>检查 value 是否是安全整数。 这个整数应该是符合 IEEE-754 标准的非双精度浮点数。</p>
</blockquote>

<h3 id="_isset">_.isSet</h3>

<blockquote>
  <p>检查 value 是否是 Set 对象。</p>
</blockquote>

<h3 id="_isstring">_.isString</h3>

<blockquote>
  <p>检查 value 是否是原始字符串或者对象。</p>
</blockquote>

<h3 id="_issymbol">_.isSymbol</h3>

<blockquote>
  <p>检查 value 是否是原始 Symbol 或者对象。</p>
</blockquote>

<h3 id="_istypedarray">_.isTypedArray</h3>

<blockquote>
  <p>检查 value 是否是TypedArray。</p>
</blockquote>

<h3 id="_isundefined">_.isUndefined</h3>

<blockquote>
  <p>检查 value 是否是 undefined.</p>
</blockquote>

<h3 id="_isweakmap">_.isWeakMap</h3>

<blockquote>
  <p>检查 value 是否是 WeakMap 对象</p>
</blockquote>

<h3 id="_isweakset">_.isWeakSet</h3>

<blockquote>
  <p>检查 value 是否是 WeakSet 对象</p>
</blockquote>

<h3 id="_lt">_.lt</h3>

<blockquote>
  <p>检查 value 是否是 小于 other。</p>
</blockquote>

<h3 id="_lte">_.lte</h3>

<blockquote>
  <p>检查 value 是否是 小于等于 other.</p>
</blockquote>

<h3 id="_toarray">_.toArray</h3>

<blockquote>
  <p>转换 value 为数组</p>
</blockquote>

<h3 id="_tofinite">_.toFinite</h3>

<blockquote>
  <p>将值转换为有限数字。</p>
</blockquote>

<h3 id="_tointeger">_.toInteger</h3>

<blockquote>
  <p>转换 value 为整数</p>
</blockquote>

<h3 id="_tolength">_.toLength</h3>

<blockquote>
  <p>转换 value 为用作类数组对象的长度整数。</p>
</blockquote>

<h3 id="_tonumber">_.toNumber</h3>

<blockquote>
  <p>转换 value 为数值</p>
</blockquote>

<h3 id="_toplainobject">_.toPlainObject</h3>

<blockquote>
  <p>转换 value 为普通对象。 包括继承的可枚举属性。</p>
</blockquote>

<h3 id="_tosafeinteger">_.toSafeInteger</h3>

<blockquote>
  <p>转换 value 为安全整数。 安全整数可以用于比较和准确的表示。</p>
</blockquote>

<h3 id="_tostring">_.toString</h3>

<blockquote>
  <p>如果 value 不是字符串，将其转换为字符串。 null 和 undefined 将返回空字符串。</p>
</blockquote>

<h1 id="6math">6.Math</h1>

<blockquote>
  <p>适用于数值类型，常用于执行数学运算</p>
</blockquote>

<h3 id="_add">_.add</h3>

<blockquote>
  <p>相加两个数</p>
</blockquote>

<h3 id="_ceil">_.ceil</h3>

<blockquote>
  <p>根据 precision 向上舍入 number。</p>
</blockquote>

<h3 id="_divide">_.divide</h3>

<blockquote>
  <p>除以两个数字</p>
</blockquote>

<h3 id="_floor">_.floor</h3>

<blockquote>
  <p>根据 precision 向下保留 number。</p>
</blockquote>

<h3 id="_max">_.max</h3>

<blockquote>
  <p>计算 array 中最大的值。 如果 array 是 空的或者假值将会返回 undefined。</p>
</blockquote>

<h3 id="_maxby">_.maxBy</h3>

<blockquote>
  <p>这个方法类似 _.max 除了它接受 iteratee 调用每一个元素，根据返回的 value 决定排序准则。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h3 id="_mean">_.mean</h3>

<blockquote>
  <p>计算 array 的平均值。</p>
</blockquote>

<h3 id="_meanby">_.meanBy</h3>

<blockquote>
  <p>此方法与_.mean类似，不同之处在于它接受为数组中的每个元素调用的iteratee，以生成要平均的值。使用一个参数调用iteratee :( value）。以来</p>
</blockquote>

<h3 id="_min">_.min</h3>

<blockquote>
  <p>计算 array 中最小的值。 如果 array 是 空的或者假值将会返回 undefined。</p>
</blockquote>

<h3 id="_minby">_.minBy</h3>

<blockquote>
  <p>这个方法类似 _.min。 除了它接受 iteratee 调用每一个元素，根据返回的 value 决定排序准则。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h3 id="_multiply">_.multiply</h3>

<blockquote>
  <p>相乘</p>
</blockquote>

<h3 id="_round">_.round</h3>

<blockquote>
  <p>根据 precision 四舍五入 number。</p>
</blockquote>

<h3 id="_subtract">_.subtract</h3>

<blockquote>
  <p>相减</p>
</blockquote>

<h3 id="_sum">_.sum</h3>

<blockquote>
  <p>计算 array 中值的总和</p>
</blockquote>

<h3 id="_sumby">_.sumBy</h3>

<blockquote>
  <p>这个方法类似 _.sum。 除了它接受 iteratee 调用每一个元素，根据返回的 value 决定如何计算。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h1 id="7number数字">7.Number(数字)</h1>

<blockquote>
  <p>适用于生成随机数，比较数值与数值区间的关系</p>
</blockquote>

<h3 id="_clamp">_.clamp</h3>

<blockquote>
  <p>返回限制在 min 和 max 之间的值</p>
</blockquote>

<h3 id="_inrange">_.inRange</h3>

<blockquote>
  <p>检查 n 是否在 start 与 end 之间，但不包括 end。 如果 end 没有指定，那么 start 设置为0。 如果 start 大于 end，那么参数会交换以便支持负范围</p>
</blockquote>

<h3 id="_random">_.random</h3>

<blockquote>
  <p>产生一个包括 min 与 max 之间的数。 如果只提供一个参数返回一个0到提供数之间的数。 如果 floating 设为 true，或者 min 或 max 是浮点数，结果返回浮点数。</p>
</blockquote>

<h1 id="8object对象">8.Object(对象)</h1>

<blockquote>
  <p>适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作</p>
</blockquote>

<h3 id="_assign">_.assign</h3>

<blockquote>
  <p>分配来源对象的可枚举属性到目标对象上。 来源对象的应用规则是从左到右，随后的下一个对象的属性会覆盖上一个对象的属性。</p>
</blockquote>

<h3 id="_assignin">_.assignIn</h3>

<blockquote>
  <p>这个方法类似 _.assign。 除了它会遍历并继承来源对象的属性。</p>
</blockquote>

<h3 id="_assigninwith">_.assignInwith</h3>

<blockquote>
  <p>这个方法类似 _.assignIn。 除了它接受一个 customizer决定如何分配值。 如果customizer返回undefined将会由分配处理方法代替。customizer` 会传入5个参数：(objValue, srcValue, key, object, source)</p>
</blockquote>

<h3 id="_assignwith">_.assignWith</h3>

<blockquote>
  <p>这个方法类似 _.assign。 除了它接受一个 customizer决定如何分配值。 如果customizer返回undefined将会由分配处理方法代替。customizer` 会传入5个参数：(objValue, srcValue, key, object, source)</p>
</blockquote>

<h3 id="_at">_.at</h3>

<blockquote>
  <p>根据 object 的路径获取值为数组。</p>
</blockquote>

<h3 id="_create">_.create</h3>

<blockquote>
  <p>创建一个继承 prototype 的对象。 如果提供了 properties，它的可枚举属性会被分配到创建的对象上。</p>
</blockquote>

<h3 id="_defaults">_.defaults</h3>

<blockquote>
  <p>分配来源对象的可枚举属性到目标对象所有解析为 undefined 的属性上。 来源对象从左到右应用。 一旦设置了相同属性的值，后续的将被忽略掉。</p>
</blockquote>

<h3 id="_defaultsdeep">_.defaultsDeep</h3>

<blockquote>
  <p>这个方法类似 _.defaults，除了它会递归分配默认属性。</p>
</blockquote>

<h3 id="_entries-topairs">_.entries-&gt;toPairs</h3>

<h3 id="_entriesin-topairsin">_.entriesIn-&gt;toPairsIn</h3>

<h3 id="_extend-assignin">_.extend-&gt;assignIn</h3>

<h3 id="_extendwith-assigninwith">_.extendWith-&gt;assignInwith</h3>

<h3 id="_findkey">_.findKey</h3>

<blockquote>
  <p>这个方法类似 _.find。 除了它返回最先被 predicate 判断为真值的元素 key，而不是元素本身。</p>
</blockquote>

<h3 id="_findlastkey">_.findLastKey</h3>

<blockquote>
  <p>这个方法类似 _.findKey。 不过它是反方向开始遍历的。</p>
</blockquote>

<h3 id="_forin">_.forIn</h3>

<blockquote>
  <p>使用 iteratee 遍历对象的自身和继承的可枚举属性。 iteratee 会传入3个参数：(value, key, object)。 如果返回 false，iteratee 会提前退出遍历。</p>
</blockquote>

<h3 id="_forinright">_.forInRight</h3>

<blockquote>
  <p>这个方法类似 _.forIn。 除了它是反方向开始遍历的。</p>
</blockquote>

<h3 id="_forown">_.forOwn</h3>

<blockquote>
  <p>使用 iteratee 遍历自身的可枚举属性。 iteratee 会传入3个参数：(value, key, object)。 如果返回 false，iteratee 会提前退出遍历。</p>
</blockquote>

<h3 id="_forownright">_.forOwnRight</h3>

<blockquote>
  <p>这个方法类似 _.forOwn。 除了它是反方向开始遍历的。</p>
</blockquote>

<h3 id="_functions">_.functions</h3>

<blockquote>
  <p>返回一个 function 对象自身可枚举属性名的数组。</p>
</blockquote>

<h3 id="_functionsin">_.functionsIn</h3>

<blockquote>
  <p>返回一个 function 对象自身和继承的可枚举属性名的数组。</p>
</blockquote>

<h3 id="_get">_.get</h3>

<blockquote>
  <p>根据对象路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代</p>
</blockquote>

<h3 id="_has">_.has</h3>

<blockquote>
  <p>检查 path 是否是对象的直接属性。</p>
</blockquote>

<h3 id="_hasin">_.hasIn</h3>

<blockquote>
  <p>检查 path 是否是对象的直接 或者 继承属性。</p>
</blockquote>

<h3 id="_invert">_.invert</h3>

<blockquote>
  <p>创建一个键值倒置的对象。 如果 object 有重复的值，后面的值会覆盖前面的值。 如果 multiVal 为 true，重复的值则组成数组。</p>
</blockquote>

<h3 id="_invertby">_.invertBy</h3>

<blockquote>
  <p>这个方法类似 _.invert。 除了它接受 iteratee 调用每一个元素，可在返回值中定制key。 iteratee 会传入1个参数：(value)。</p>
</blockquote>

<h3 id="_invoke">_.invoke</h3>

<blockquote>
  <p>调用对象路径的方法</p>
</blockquote>

<h3 id="_keys">_.keys</h3>

<blockquote>
  <p>创建 object 自身可枚举属性名为一个数组。</p>
</blockquote>

<h3 id="_keysin">_.keysIn</h3>

<blockquote>
  <p>创建 object 自身 或 继承的可枚举属性名为一个数组。</p>
</blockquote>

<h3 id="_mapkeys">_.mapKeys</h3>

<blockquote>
  <p>反向版 _.mapValues。 这个方法创建一个对象，对象的值与源对象相同，但 key 是通过 iteratee 产生的。</p>
</blockquote>

<h3 id="_mapvalues">_.mapValues</h3>

<blockquote>
  <p>创建一个对象，对象的key相同，值是通过 iteratee 产生的。 iteratee 会传入3个参数： (value, key, object)</p>
</blockquote>

<h3 id="_merge">_.merge</h3>

<blockquote>
  <p>递归合并来源对象的自身和继承的可枚举属性到目标对象。 跳过来源对象解析为 undefined 的属性。 数组和普通对象会递归合并，其他对象和值会被直接分配。 来源对象从左到右分配，后续的来源对象属性会覆盖之前分配的属性。</p>
</blockquote>

<h3 id="_mergewith">_.mergeWith</h3>

<blockquote>
  <p>这个方法类似 _.merge。 除了它接受一个 customizer 决定如何合并。 如果 customizer 返回 undefined 将会由合并处理方法代替。</p>
</blockquote>

<h3 id="_omit">_.omit</h3>

<blockquote>
  <p>反向版 _.pick。 这个方法返回忽略属性之外的自身和继承的可枚举属性。</p>
</blockquote>

<h3 id="_omitby">_.omitBy</h3>

<blockquote>
  <p>反向版 _.pickBy。 这个方法返回经 predicate 判断不是真值的属性的自身和继承的可枚举属性。</p>
</blockquote>

<h3 id="_pick">_.pick</h3>

<blockquote>
  <p>创建一个从 object 中选中的属性的对象。</p>
</blockquote>

<h3 id="_pickby">_.pickBy</h3>

<blockquote>
  <p>创建一个从 object 中经 predicate 判断为真值的属性为对象。 predicate 会传入1个参数：(value)</p>
</blockquote>

<h3 id="_result">_.result</h3>

<blockquote>
  <p>这个方法类似 _.get。 除了如果解析到的值是一个函数的话，就绑定 this 到这个函数并返回执行后的结果。</p>
</blockquote>

<h3 id="_set">_.set</h3>

<blockquote>
  <p>设置值到对象对应的属性路径上，如果没有则创建这部分路径。 缺少的索引属性会创建为数组，而缺少的属性会创建为对象。 使用 _.setWith 定制创建。</p>
</blockquote>

<h3 id="_setwith">_.setWith</h3>

<blockquote>
  <p>这个方法类似 _.set。 除了它接受一个 customizer 决定如何设置对象路径的值。 如果 customizer 返回 undefined 将会有它的处理方法代替。 customizer 会传入3个参数：(nsValue, key, nsObject) 注意: 这个方法会改变源对象</p>
</blockquote>

<h3 id="_topairs">_.toPairs</h3>

<blockquote>
  <p>创建一个对象自身可枚举属性的键值对数组。</p>
</blockquote>

<h3 id="_topairsin">_.toPairsIn</h3>

<blockquote>
  <p>创建一个对象自身和继承的可枚举属性的键值对数组。</p>
</blockquote>

<h3 id="_transform">_.transform</h3>

<blockquote>
  <p>_.reduce 的代替方法。 这个方法会改变对象为一个新的 accumulator 对象，来自每一次经 iteratee 处理自身可枚举对象的结果。 每次调用可能会改变 accumulator 对象。 iteratee 会传入4个对象：(accumulator, value, key, object)。 如果返回 false，iteratee 会提前退出</p>
</blockquote>

<h3 id="_unset">_.unset</h3>

<blockquote>
  <p>移除对象路径的属性。 注意: 这个方法会改变源对象</p>
</blockquote>

<h3 id="_update">_.update</h3>

<h3 id="_updatewith">_.updateWith</h3>

<h3 id="_values">_.values</h3>

<blockquote>
  <p>创建 object 自身可枚举属性的值为数组</p>
</blockquote>

<h3 id="_valuesin">_.valuesIn</h3>

<blockquote>
  <p>创建 object 自身和继承的可枚举属性的值为数组</p>
</blockquote>

<h1 id="9seq">9.Seq</h1>

<blockquote>
  <p>常用于创建链式调用，提高执行性能（惰性计算）</p>
</blockquote>

<h3 id="_chain">_.chain</h3>

<blockquote>
  <p>创建一个经 lodash 包装的对象以启用显式链模式，要解除链必须使用 _#value 方法。</p>
</blockquote>

<h3 id="_tap">_.tap</h3>

<blockquote>
  <p>这个方法调用一个 interceptor 并返回 value。interceptor 传入一个参数：(value) 目的是 进入 链的中间以便执行操作。</p>
</blockquote>

<h3 id="_thru">_.thru</h3>

<blockquote>
  <p>这个方法类似 _.tap， 除了它返回 interceptor 的返回结果</p>
</blockquote>

<h3 id="_prototypesymboliterator">_.prototype[Symbol.iterator]</h3>

<h3 id="_prototypeat">_.prototype.at</h3>

<blockquote>
  <p>这个方法是 _.at 的包装版本</p>
</blockquote>

<h3 id="_prototypechain">_.prototype.chain</h3>

<blockquote>
  <p>开启包装对象的显式链。</p>
</blockquote>

<h3 id="_prototypecommit">_.prototype.commit</h3>

<blockquote>
  <p>执行链式队列并返回结果</p>
</blockquote>

<h3 id="_prototypenext">_.prototype.next</h3>

<blockquote>
  <p>获得包装对象的下一个值，遵循 iterator 协议</p>
</blockquote>

<h3 id="_prototypeplant">_.prototype.plant</h3>

<blockquote>
  <p>创建一个链式队列的拷贝，传入的值作为链式队列的值。</p>
</blockquote>

<h3 id="_prototypereverse">_.prototype.reverse</h3>

<h3 id="_prototypetojson-value">_.prototype.toJSON-&gt;value</h3>

<h3 id="_prototypevalueof-value">_.prototype.valueOf-&gt;value</h3>

<h1 id="10string字符串">10.String(字符串)</h1>

<h3 id="_camelcase">_.camelCase</h3>

<blockquote>
  <p>转换字符串为 驼峰写法</p>
</blockquote>

<h3 id="_capitalize">_.capitalize</h3>

<blockquote>
  <p>转换字符串首字母为大写，剩下为小写</p>
</blockquote>

<h3 id="_deburr">_.deburr</h3>

<blockquote>
  <p>转换 latin-1 supplementary letters#Character_table) 为基本拉丁字母，并删除变音符。</p>
</blockquote>

<h3 id="_endswith">_.endsWith</h3>

<blockquote>
  <p>检查给定的字符是否是字符串的结尾</p>
</blockquote>

<h3 id="_escape">_.escape</h3>

<blockquote>
  <p>转义字符 “&amp;”, “&lt;”, “&gt;”, ‘”’, “’”, 以及 “`” 为HTML实体字符。</p>
</blockquote>

<h3 id="_escaperegexp">_.escapeRegExp</h3>

<blockquote>
  <p>转义RegExp 中特殊的字符 “^”, “$”, “", “.”, “*”, “+”, “?”, “(“, “)”, “[”, “]”, “{“, “}”, 以及 “|“。</p>
</blockquote>

<h3 id="_kebabcase">_.kebabCase</h3>

<blockquote>
  <p>转换字符串为 kebab case。</p>
</blockquote>

<h3 id="_lowercase">_.lowerCase</h3>

<blockquote>
  <p>以空格分开单词并转换为小写。</p>
</blockquote>

<h3 id="_lowerfirst">_.lowerFirst</h3>

<blockquote>
  <p>转换首字母为小写。</p>
</blockquote>

<h3 id="_pad">_.pad</h3>

<blockquote>
  <p>如果字符串长度小于 length 则从左到右填充字符。 如果没法平均分配，则截断超出的长度。</p>
</blockquote>

<h3 id="_padend">_.padEnd</h3>

<blockquote>
  <p>如果字符串长度小于 length 则在右侧填充字符。 如果超出长度则截断超出的部分</p>
</blockquote>

<h3 id="_padstart">_.padStart</h3>

<blockquote>
  <p>如果字符串长度小于 length 则在左侧填充字符。 如果超出长度则截断超出的部分</p>
</blockquote>

<h3 id="_parseint">_.parseInt</h3>

<blockquote>
  <p>以指定的基数转换字符串为整数。 如果基数是 undefined 或者 0，则基数默认是10，如果字符串是16进制，则基数为16。</p>
</blockquote>

<h3 id="_repeat">_.repeat</h3>

<blockquote>
  <p>重复 N 次字符串</p>
</blockquote>

<h3 id="_replace">_.replace</h3>

<blockquote>
  <p>替换字符串中匹配的内容为给定的内容</p>
</blockquote>

<h3 id="_snakecase">_.snakeCase</h3>

<blockquote>
  <p>转换字符串为 snake case</p>
</blockquote>

<h3 id="_split">_.split</h3>

<blockquote>
  <p>以 separator 拆分字符串</p>
</blockquote>

<h3 id="_startcase">_.startCase</h3>

<blockquote>
  <p>转换字符串为 start case</p>
</blockquote>

<h3 id="_startswith">_.startsWith</h3>

<blockquote>
  <p>检查字符串是否以 target 开头。</p>
</blockquote>

<h3 id="_template">_.template</h3>

<blockquote>
  <p>创建一个预编译模板方法，可以插入数据到模板中 “interpolate” 分隔符相应的位置。 HTML会在 “escape” 分隔符中转换为相应实体。 在 “evaluate” 分隔符中允许执行JavaScript代码。 在模板中可以自由访问变量。 如果设置了选项对象，则会优先覆盖 _.templateSettings 的值。</p>
</blockquote>

<h3 id="_tolower">_.toLower</h3>

<blockquote>
  <p>转换整体的字符串为小写</p>
</blockquote>

<h3 id="_toupper">_.toUpper</h3>

<blockquote>
  <p>转换整体的字符串为大写</p>
</blockquote>

<h3 id="_trim">_.trim</h3>

<blockquote>
  <p>从字符串中移除前面和后面的空白 或 指定的字符。</p>
</blockquote>

<h3 id="_trimend">_.trimEnd</h3>

<blockquote>
  <p>移除字符串后面的空白 或 指定的字符。</p>
</blockquote>

<h3 id="_trimstart">_.trimStart</h3>

<blockquote>
  <p>移除字符串中前面的空白 或 指定的字符。</p>
</blockquote>

<h3 id="_truncate">_.truncate</h3>

<blockquote>
  <p>截断字符串，如果字符串超出了限定的最大值。 被截断的字符串后面会以 omission 代替，omission 默认是 “…“。</p>
</blockquote>

<h3 id="_unescape">_.unescape</h3>

<blockquote>
  <p>反向版 _.escape。 这个方法转换 HTML 实体 &amp;, &lt;, &gt;, ", ', 以及 ` 为对应的字符。</p>
</blockquote>

<h3 id="_uppercase">_.upperCase</h3>

<blockquote>
  <p>转换字符串为空格分割的大写单词</p>
</blockquote>

<h3 id="_upperfirst">_.upperFirst</h3>

<blockquote>
  <p>转换首字母为大写。</p>
</blockquote>

<h3 id="_words">_.words</h3>

<blockquote>
  <p>拆分字符串中的词为数组</p>
</blockquote>

<h1 id="11util工具">11.Util(工具)</h1>

<h3 id="_attempt">_.attempt</h3>

<blockquote>
  <p>尝试调用函数，返回结果 或者 错误对象。 任何附加的参数都会在调用时传给函数。</p>
</blockquote>

<h3 id="_bindall">_.bindAll</h3>

<blockquote>
  <p>绑定对象的方法到对象本身，覆盖已存在的方法。</p>
</blockquote>

<h3 id="_cond">_.cond</h3>

<blockquote>
  <p>创建一个函数。 这个函数会遍历 pairs，并执行最先返回真值对应的函数，并绑定 this 及传入创建函数的参数</p>
</blockquote>

<h3 id="_conforms">_.conforms</h3>

<blockquote>
  <p>创建一个函数。 这个函数会调用 source 的属性名对应的 predicate 与传入对象相对应属性名的值进行 predicate 处理。 如果都符合返回 true，否则返回 false</p>
</blockquote>

<h3 id="_constant">_.constant</h3>

<blockquote>
  <p>创建一个返回 value 的函数</p>
</blockquote>

<h3 id="_defaultto">_.defaultTo</h3>

<h3 id="_flow">_.flow</h3>

<blockquote>
  <p>创建一个函数。 返回的结果是调用提供函数的结果，this 会绑定到创建函数。 每一个连续调用，传入的参数都是前一个函数返回的结果。</p>
</blockquote>

<h3 id="_flowright">_.flowRight</h3>

<blockquote>
  <p>这个方法类似 _.flow，除了它调用函数的顺序是从右往左的。</p>
</blockquote>

<h3 id="_identity">_.identity</h3>

<blockquote>
  <p>这个方法返回首个提供的参数</p>
</blockquote>

<h3 id="_iteratee">_.iteratee</h3>

<blockquote>
  <p>创建一个调用 func 的函数。 如果 func 是一个属性名，传入包含这个属性名的对象，回调返回对应属性名的值。 如果 func 是一个对象，传入的元素有相同的对象属性，回调返回 true。 其他情况返回 false。</p>
</blockquote>

<h3 id="_matches">_.matches</h3>

<blockquote>
  <p>创建一个深比较的方法来比较给定的对象和 source 对象。 如果给定的对象拥有相同的属性值返回 true，否则返回 false</p>
</blockquote>

<h3 id="_matchesproperty">_.matchesProperty</h3>

<blockquote>
  <p>创建一个深比较的方法来比较给定对象的 path 的值是否是 srcValue。 如果是返回 true，否则返回 false</p>
</blockquote>

<h3 id="_method">_.method</h3>

<blockquote>
  <p>创建一个调用给定对象 path 上的函数。 任何附加的参数都会传入这个调用函数中。</p>
</blockquote>

<h3 id="_methodof">_.methodOf</h3>

<blockquote>
  <p>反向版 _.method。 这个创建一个函数调用给定 object 的 path 上的方法， 任何附加的参数都会传入这个调用函数中。</p>
</blockquote>

<h3 id="_mixin">_.mixin</h3>

<blockquote>
  <p>添加来源对象自身的所有可枚举函数属性到目标对象。 如果 object 是个函数，那么函数方法将被添加到原型链上。</p>
</blockquote>

<h3 id="_noconflict">_.noConflict</h3>

<blockquote>
  <p>释放 _ 为原来的值，并返回一个 lodash 的引用</p>
</blockquote>

<h3 id="_noop">_.noop</h3>

<blockquote>
  <p>无论传递什么参数，都返回 undefined。</p>
</blockquote>

<h3 id="_ntharg">_.nthArg</h3>

<blockquote>
  <p>创建一个返回第 N 个参数的函数。</p>
</blockquote>

<h3 id="_over">_.over</h3>

<blockquote>
  <p>创建一个传入提供的参数的函数并调用 iteratees 返回结果的函数</p>
</blockquote>

<h3 id="_overevery">_.overEvery</h3>

<blockquote>
  <p>创建一个传入提供的参数的函数并调用 iteratees 判断是否 全部 都为真值的函数。</p>
</blockquote>

<h3 id="_oversome">_.overSome</h3>

<blockquote>
  <p>创建一个传入提供的参数的函数并调用 iteratees 判断是否 存在 有真值的函数。</p>
</blockquote>

<h3 id="_property">_.property</h3>

<blockquote>
  <p>创建一个返回给定对象的 path 的值的函数。</p>
</blockquote>

<h3 id="_propertyof">_.propertyOf</h3>

<blockquote>
  <p>反向版 _.property。 这个方法创建的函数返回给定 path 在对象上的值。</p>
</blockquote>

<h3 id="_range">_.range</h3>

<blockquote>
  <p>创建一个包含从 start 到 end，但不包含 end 本身范围数字的数组。 如果 start 是负数，而 end 或 step 没有指定，那么 step 从 -1 为开始。 如果 end 没有指定，start 设置为 0。 如果 end 小于 start，会创建一个空数组，除非指定了 step。</p>
</blockquote>

<h3 id="_rangeright">_.rangeRight</h3>

<blockquote>
  <p>这个方法类似 _.range， 除了它是降序生成值的。</p>
</blockquote>

<h3 id="_runincontext">_.runInContext</h3>

<blockquote>
  <p>创建一个给定上下文对象的原始的 lodash 函数。</p>
</blockquote>

<h3 id="_stubarray">_.stubArray</h3>

<h3 id="_stubfalse">_.stubFalse</h3>

<h3 id="_stubobject">_.stubObject</h3>

<h3 id="_stubstring">_.stubString</h3>

<h3 id="_stubtrue">_.stubTrue</h3>

<h3 id="_times">_.times</h3>

<blockquote>
  <p>调用 iteratee N 次，每次调用返回的结果存入到数组中。 iteratee 会传入1个参数：(index)。</p>
</blockquote>

<h3 id="_topath">_.toPath</h3>

<blockquote>
  <p>创建 value 为属性路径的数组</p>
</blockquote>

<h3 id="_uniqueid">_uniqueId</h3>

<blockquote>
  <p>创建唯一ID。 如果提供了 prefix，会被添加到ID前缀上。</p>
</blockquote>

<h1 id="12porperties属性">12.Porperties(属性)</h1>

<h3 id="_version">_.VERSION</h3>

<h3 id="_templatesettings">_.templateSettings</h3>

<h3 id="_templatesettingsescape">_.templateSettings.escape</h3>

<h3 id="_templatesettingsevaluate">_.templateSettings.evaluate</h3>

<h3 id="_templatesettingsimports">_.templateSettings.imports</h3>

<h3 id="_templatesettingsinterpolate">_.templateSettings.interpolate</h3>

<h3 id="_templatesettingsvariable">_.templateSettings.variable</h3>

<h1 id="13methods方法">13.Methods(方法)</h1>

<h3 id="templatesettingsimports"><em>.templateSettings.imports.</em></h3>

<h1 id="14小菜常用方法">14.小菜常用方法</h1>

<h4 id="_map-1">_.map</h4>

<p>获取一个数组对象中的value值，并返回一个数组</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">19</span><span class="p">},{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">王五</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">20</span><span class="p">},{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">老6</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">21</span><span class="p">}]</span>

<span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">)</span>

<span class="p">[</span><span class="dl">'</span><span class="s1">张三</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">王五</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">老6</span><span class="dl">'</span><span class="p">]</span>
</code></pre></div></div>
<h4 id="_assignin-1">_.assignIn</h4>

<p>一个对象属性替换掉另个对象的属性，就是合并</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱大饼</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="na">child</span><span class="p">:{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱小兵</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">5</span><span class="p">}}</span>
<span class="kd">let</span> <span class="nx">user1</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">王老五</span><span class="dl">"</span><span class="p">}</span>
<span class="nx">_</span><span class="p">.</span><span class="nx">assignIn</span><span class="p">(</span><span class="nx">user</span><span class="p">,</span><span class="nx">user1</span><span class="p">)</span>

<span class="p">{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">王老五</span><span class="dl">'</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="nx">child</span><span class="p">:{</span><span class="nl">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱小兵</span><span class="dl">'</span><span class="p">,</span><span class="nx">age</span><span class="p">:</span><span class="mi">5</span><span class="p">}}</span>
</code></pre></div></div>

<h4 id="_clonedeep-1">_.cloneDeep</h4>

<p>深拷贝</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱大饼</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="na">child</span><span class="p">:{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱小兵</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">5</span><span class="p">}}</span>
<span class="kd">let</span> <span class="nx">user1</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">cloneDeep</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>

<span class="nx">user1</span><span class="p">.</span><span class="nx">child</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">王老五</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">//user</span>
<span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱大饼</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="na">child</span><span class="p">:{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱小兵</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">5</span><span class="p">}}</span>

<span class="c1">//user1</span>
<span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">酱大饼</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span><span class="na">child</span><span class="p">:{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">王老五</span><span class="dl">'</span><span class="p">,</span><span class="na">age</span><span class="p">:</span><span class="mi">5</span><span class="p">}}</span>
</code></pre></div></div>

:ET
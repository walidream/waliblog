I",<p>大多数面向对象语言都不支持多重继承，因为这会导致著名的<a href="https://en.wikipedia.org/wiki/Diamond_problem" title="https://en.wikipedia.org/wiki/Diamond_problem">Diamond problem</a>， 而 Python 虽然形式上支持多重继承，但其实现机制却是利用 mixin，从而有效 地避免了 Diamond problem。</p>

<p><a href="https://github.com/dengshuan/notes/blob/master/techs/python-mixins.org" title="https://github.com/dengshuan/notes/blob/master/techs/python-mixins.org">github dengshuan博主</a></p>

<h1 id="1什么是mixin">1.什么是mixin</h1>

<p><a href="http://en.wikipedia.org/wiki/Mixin" title="http://en.wikipedia.org/wiki/Mixin">Mixin</a> 本意是混入，程序中用来将不同功能(functionality)组合起来，从而为 类提供多种特性。而虽然继承(inheritance)也可以实现多种功能，但继承一般 有从属关系，即子类通常是父类更加具体的类。而 mixin 则更多的是功能上的 组合，因而相当于是接口（带实现的接口）。</p>

<p>好比是联想电脑与电脑之间是继承关系，因而联想电脑具备电脑的各种功能；而 联想电脑与键盘之间则是 mixin 关系，同样也具备键盘的各种功能。</p>

<p>一般编程语言都不允许多重继承，主要是为了避免 diamond problem，即两个父 类如果有共同的祖父类，但对祖父类相同部分做了不同的修改，则这个类再继承 两个父类就会产生冲突。</p>

<p><img src="http://walidream.com:9999/blogImage/python/python_65.png" alt="ssl" /></p>

<p>类似于 git 版本控制中，如果两个人对同一段代码做了不同的修改，则合并时 就需要手动解决冲突。编程语言如果碰到 diamond problem 时依赖程序员决定 用哪个父类的特性，就会变得非常复杂而且容易产生歧义。</p>

<p>从上面分析可以看出其实单从功能上来说，完全可以用 mixin 取代继承，从而 可以不要类这个概念。最近几年新出的编程语言 Rust 和 Go 里面就没有类 (class)以及继承，但并不影响代码复用，它们也正是利用 mixin 这种机制实现 的代码复用，例如 Rust 中用特征(Trait)取代了类和接口。</p>

<p>两种观点其实是两种不同的世界观，目前类与继承的概念则更为流行，而且符合 人们对事物的认知：人们对白猫、黑猫、花猫观察后更容易抽象出猫的概念，而 不是将这些事物作为无规律的组合去看待。</p>

<h1 id="2python中的mixin">2.Python中的mixin</h1>

<p>理解了 mixin 概念之后，再将其运用到 Python 中，理解（形式上）多重继承 就会容易许多。python 对于 mixin 命名方式一般以 MixIn, able, ible 为后缀</p>

<p>由于 mixin 是组合，因而是做加法，为已有的类添加新功能，而不像继承一样 下一级会覆盖上一级相同的属性或方法，但在某些方面仍然表现得与继承一样， 例如类的实例也是每个 mixin 的实例。mixin 使用不当会导致类的命名空间污 染，所以要尽量避免 mixin 中定义相同方法，对于相同的方法，有时很难区分 实例到底使用的是哪个方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Mixin1</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"mixin 1"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">which_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">test</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Mixin2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"mixin 2"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyClass1</span><span class="p">(</span><span class="n">Mixin1</span><span class="p">,</span> <span class="n">Mixin2</span><span class="p">):</span>
    <span class="k">pass</span>                        <span class="c1"># 按从左到右顺序从 mixin 中获取功能并添加到 MyClass
</span>
<span class="k">class</span> <span class="nc">Myclass2</span><span class="p">(</span><span class="n">Mixin1</span><span class="p">,</span> <span class="n">Mixin2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>             <span class="c1"># 已有 test 方法，因而不会再添加 Mixin1, Mixin2 的 test 方法
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"my class 2"</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">MyClass1</span><span class="p">()</span>
<span class="n">c1</span><span class="p">.</span><span class="n">test</span><span class="p">()</span>                       <span class="c1"># =&gt; "mixin 1"
</span><span class="n">c2</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">()</span>
<span class="n">c2</span><span class="p">.</span><span class="n">test</span><span class="p">()</span>                       <span class="c1"># =&gt; "my class 2"
</span><span class="n">c2</span><span class="p">.</span><span class="n">which_test</span><span class="p">()</span>                 <span class="c1"># =&gt; "my class 2"
</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">Mixin1</span><span class="p">)</span>          <span class="c1"># =&gt; True
</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">MyClass1</span><span class="p">,</span> <span class="n">Mixin2</span><span class="p">)</span>    <span class="c1"># =&gt; True
</span></code></pre></div></div>

<p>Mixin 强调的是功能而不像继承那样包括所有功能和数据域，但利用 mixin 同 样也可以实现代码复用，下面这段代码来自Stack Overflow，当然 <a href="http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful" title="http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful">functools.total_ordering()</a> 装饰器已经提供相同功能了，这里仅用来说明 mixin 实现代码复用。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comparable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">other</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span> <span class="o">!=</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">&lt;=</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">&gt;</span> <span class="n">other</span>


<span class="k">class</span> <span class="nc">Integer</span><span class="p">(</span><span class="n">Comparable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>


<span class="k">class</span> <span class="nc">Char</span><span class="p">(</span><span class="n">Comparable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
</code></pre></div></div>
<p>下面是 Python2 中动态加入 mixin 的方法[fn:1]，python3 中已经不支持这种 方法了，python3 可能需要借助 type 等元编程工具实现[fn:2]动态 mixin</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">MixIn</span><span class="p">(</span><span class="n">pyClass</span><span class="p">,</span> <span class="n">mixInClass</span><span class="p">,</span> <span class="n">makeLast</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mixInClass</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pyClass</span><span class="p">.</span><span class="n">__bases__</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">makeLast</span><span class="p">:</span>
            <span class="n">pyClass</span><span class="p">.</span><span class="n">__bases__</span> <span class="o">+=</span> <span class="p">(</span><span class="n">mixInClass</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pyClass</span><span class="p">.</span><span class="n">__bases__</span> <span class="o">=</span> <span class="p">(</span><span class="n">mixInClass</span><span class="p">,)</span> <span class="o">+</span> <span class="n">pyClass</span><span class="p">.</span><span class="n">__bases</span>
</code></pre></div></div>

<p>不过尽管动态 mixin 是可能的，但实际使用中要尽量避免这样做，因为可能会 使所有使用这个 mixin 的实例出现一些不可预知的问题。</p>

:ET
I"E{<p>装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>

<ul>
  <li><a href="https://foofish.net/python-decorator.html" title="https://foofish.net/python-decorator.html">理解 Python 装饰器看这一篇就够了</a></li>
</ul>

<h1 id="1简单装饰器">1.简单装饰器</h1>

<p>为了更好的说明装饰器是什么，我们先来看一个简单例子，虽然实际代码可能比这复杂很多：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a f1'</span><span class="p">)</span>
</code></pre></div></div>

<p>有一天，当我发现<code class="language-plaintext highlighter-rouge">f1</code>函数不能满足现在的业务需要，需要在函数执行前打印一句话，于是在代码中添加日志代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a f1'</span><span class="p">)</span>
</code></pre></div></div>

<p>上面代码是实现了需求，但有一个问题，假如存在100个函数，不可能在100个函数中都添加一句打印的代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
    <span class="n">func</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a f1'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">print_info</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a f1'</span>
</code></pre></div></div>

<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 <code class="language-plaintext highlighter-rouge">f1 </code>函数，而是换成了 <code class="language-plaintext highlighter-rouge">print_info</code> 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个<code class="language-plaintext highlighter-rouge">f1</code>函数作为参数传递给<code class="language-plaintext highlighter-rouge">print_info</code>函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
        <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrappe</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a f1'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">print_info</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a f1'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">print_info</code>就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 <code class="language-plaintext highlighter-rouge">func</code> 包裹在其中，看起来像 <code class="language-plaintext highlighter-rouge">f1</code> 被 <code class="language-plaintext highlighter-rouge">print_info</code> 装饰了一样，<code class="language-plaintext highlighter-rouge">print_info</code>返回的也是一个函数，这个函数的名字叫 <code class="language-plaintext highlighter-rouge">wrapper</code>。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为<code class="language-plaintext highlighter-rouge">面向切面的编程</code>。</p>

<h1 id="2语法糖">2.语法糖</h1>

<p>如果你接触 Python 有一段时间了的话，想必你对 <code class="language-plaintext highlighter-rouge">@</code> 符号一定不陌生了，没错 <code class="language-plaintext highlighter-rouge">@</code> 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
        <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrappe</span>

<span class="o">@</span><span class="n">print_info</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a f1'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span><span class="p">()</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a f1'</span>
</code></pre></div></div>
<p>如上所示，有了<code class="language-plaintext highlighter-rouge">@</code>，我们就可以省去<code class="language-plaintext highlighter-rouge">f = print_info(f1)</code>这一句了，直接调用<code class="language-plaintext highlighter-rouge">f1</code>即可得到想要的结果。你们看到了没有<code class="language-plaintext highlighter-rouge">f1</code>函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>

<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>

<h1 id="3逻辑业务参数">3.逻辑业务参数</h1>

<p>可能有人问，如果我的业务逻辑函数<code class="language-plaintext highlighter-rouge">f1</code>需要参数怎么办？比如：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a'</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<p>为实现传参，我们需要修改装饰器：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
        <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrappe</span>

<span class="o">@</span><span class="n">print_info</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a '</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span><span class="p">(</span><span class="s">'test'</span><span class="p">)</span>
<span class="s">'start running...'</span>
<span class="s">'This is a test'</span>
</code></pre></div></div>

<h4 id="传入可变参数">传入可变参数</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrappe</span>

<span class="o">@</span><span class="n">print_info</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a '</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>

<span class="o">@</span><span class="n">print_info</span>
<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a %s,age is %d'</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span><span class="p">(</span><span class="s">'test'</span><span class="p">)</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a test'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f2</span><span class="p">(</span><span class="s">'f2'</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a f2,age is 20'</span>
</code></pre></div></div>

<h4 id="关键字参数">关键字参数</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># args是一个数组，kw一个字典
</span>        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>   
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrappe</span>

<span class="o">@</span><span class="n">print_info</span>
<span class="k">def</span> <span class="nf">f3</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a %s,age is %d'</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f3</span><span class="p">(</span><span class="s">'test'</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s">'fwqw'</span><span class="p">)</span>
<span class="s">'start runnin...'</span>
<span class="s">'This is a test,age is 20'</span>
<span class="p">{</span><span class="s">'a'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'b'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="s">'fwqw'</span><span class="p">}</span>
</code></pre></div></div>

<h1 id="4带参数的装饰器">4.带参数的装饰器</h1>

<p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 <code class="language-plaintext highlighter-rouge">f1</code> 。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_info</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="s">'warn'</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'warn is running...'</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">level</span> <span class="o">==</span> <span class="s">'info'</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'info is running...'</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="o">@</span><span class="n">print_info</span><span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="s">'warn'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'This is a %s'</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="n">f1</span><span class="p">(</span><span class="s">'test'</span><span class="p">)</span>
<span class="s">'warn is running...'</span>
<span class="s">'This is a test'</span>
</code></pre></div></div>

<p>上面的<code class="language-plaintext highlighter-rouge">print_info</code>是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用<code class="language-plaintext highlighter-rouge">@print_info(level="warn")</code>调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>

<p><code class="language-plaintext highlighter-rouge">@print_info(level="warn")</code>等价于<code class="language-plaintext highlighter-rouge">@decorator</code></p>

<h1 id="5类装饰器">5.类装饰器</h1>

<p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的<code class="language-plaintext highlighter-rouge">__call__</code>方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">'class decorator runing'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_func</span><span class="p">()</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">'class decorator ending'</span><span class="p">)</span>

<span class="o">@</span><span class="n">Foo</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">'bar'</span><span class="p">)</span>

<span class="n">bar</span><span class="p">()</span>
</code></pre></div></div>

<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的<code class="language-plaintext highlighter-rouge">docstring</code>、<code class="language-plaintext highlighter-rouge">__name__</code>、参数列表，先看例子：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 装饰器
</span><span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">with_logging</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span>      <span class="c1"># 输出 'with_logging'
</span>        <span class="k">print</span> <span class="n">func</span><span class="p">.</span><span class="n">__doc__</span>       <span class="c1"># 输出 None
</span>        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">with_logging</span>

<span class="c1"># 函数
</span><span class="o">@</span><span class="n">logged</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="s">"""does some math"""</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">logged</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<p>不难发现，函数 f 被<code class="language-plaintext highlighter-rouge">with_logging</code>取代了，当然它的<code class="language-plaintext highlighter-rouge">docstring</code>，<code class="language-plaintext highlighter-rouge">__name__</code>就是变成了<code class="language-plaintext highlighter-rouge">with_logging</code>函数的信息了。好在我们有<code class="language-plaintext highlighter-rouge">functools.wraps</code>，<code class="language-plaintext highlighter-rouge">wraps</code>本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 <code class="language-plaintext highlighter-rouge">func</code> 函数中，这使得装饰器里面的 <code class="language-plaintext highlighter-rouge">func </code>函数也有和原函数 foo 一样的元信息了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">logged</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">with_logging</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span>      <span class="c1"># 输出 'f'
</span>        <span class="k">print</span> <span class="n">func</span><span class="p">.</span><span class="n">__doc__</span>       <span class="c1"># 输出 'does some math'
</span>        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">with_logging</span>

<span class="o">@</span><span class="n">logged</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="s">"""does some math"""</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</code></pre></div></div>

<h1 id="6装饰器顺序">6.装饰器顺序</h1>

<p>一个函数还可以同时定义多个装饰器，比如：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">a</span>
<span class="o">@</span><span class="n">b</span>
<span class="o">@</span><span class="n">c</span>
<span class="k">def</span> <span class="nf">f</span> <span class="p">():</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</code></pre></div></div>

<h1 id="7装饰器的副作用">7.装饰器的副作用</h1>

<p>当我们代码中使用装饰器之后会对原来的代码有什么影响：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>  
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">decorator</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f2</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f2</span><span class="p">()</span>
<span class="n">f2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span><span class="p">()</span>
<span class="n">wrapper</span>
</code></pre></div></div>

<p>这里小菜写了2个函数<code class="language-plaintext highlighter-rouge">f1</code>和<code class="language-plaintext highlighter-rouge">f2</code>主要是用做对比，f1是添加了装饰器，f2没有添加装饰器。从输出的结果看到，f2输出了自己函数名称<code class="language-plaintext highlighter-rouge">f2</code>，添加了装饰器的f1函数输出了<code class="language-plaintext highlighter-rouge">wrapper</code>，不在是自己的函数名<code class="language-plaintext highlighter-rouge">f1</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="s">'''
            This is wrapper
        '''</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'start running...'</span><span class="p">)</span>  
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">decorator</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="s">'''
        This is a f1
    '''</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
    <span class="s">'''
        This is a f2
    '''</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f2</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">help</span><span class="p">(</span><span class="n">f2</span><span class="p">))</span>
<span class="n">f2</span><span class="p">()</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">f2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">help</span><span class="p">(</span><span class="n">f1</span><span class="p">))</span>
<span class="n">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="n">wrapper</span>
</code></pre></div></div>

<p>一般出现这种情况好像没什么大问题，但是当我们需要查看函数说明文档时，就比较麻烦了,我想查看<code class="language-plaintext highlighter-rouge">f1</code>函数说明，结果返回装饰器的<code class="language-plaintext highlighter-rouge">wrappe</code>函数说明。那么如何修改呢？</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+ from functools import wraps
</span>
def decorator(func):
<span class="gi">+    @wraps(func)
</span>    def wrapper(*args, **kw):
        '''
            This is wrapper
        '''
        print('start running...')  
        func(*args, **kw)
    return wrapper

@decorator
<span class="p">def f1():
</span>    '''
        This is a f1
    '''
    print(f1.__name__)

def f2():
    '''
        This is a f2
    '''
    print(f2.__name__)

&gt;&gt;&gt; print(help(f2))
<span class="p">f2()
</span>    This is a f2

&gt;&gt;&gt; print(helf(f1))
<span class="gi">+ f1()
+     This is a f1
</span></code></pre></div></div>

:ET
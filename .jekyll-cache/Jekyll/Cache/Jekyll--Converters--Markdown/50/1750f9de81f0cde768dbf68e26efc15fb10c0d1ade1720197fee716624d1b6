I"R<p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。在python中使用正则需要先引入正则模块<code class="language-plaintext highlighter-rouge">re</code>。</p>

<ul>
  <li><a href="https://docs.python.org/zh-cn/3/library/re.html" title="https://docs.python.org/zh-cn/3/library/re.html" target="_blank">python 正则表达式官方文档</a></li>
</ul>

<h1 id="1re模块中的参数说明">1.re模块中的参数说明</h1>

<table>
  <thead>
    <tr>
      <th>参数</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>pattern</td>
      <td>正则匹配的表达式</td>
    </tr>
    <tr>
      <td>string</td>
      <td>要匹配的字符串</td>
    </tr>
    <tr>
      <td>maxsplit</td>
      <td>分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数</td>
    </tr>
    <tr>
      <td>flags</td>
      <td>标志位，用于控制正则表达式的匹配方式</td>
    </tr>
  </tbody>
</table>

<h4 id="正则表达式修饰符---可选标志">正则表达式修饰符 - 可选标志</h4>

<table>
  <thead>
    <tr>
      <th>修饰符</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>re.A <br /> re.ASCII</td>
      <td>让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 (?a)</td>
    </tr>
    <tr>
      <td>re.DEBUG</td>
      <td>显示编译时的debug信息，没有内联标记</td>
    </tr>
    <tr>
      <td>re.I <br /> re.IGNORECASE</td>
      <td>进行忽略大小写匹配；表达式如 [A-Z] 也会匹配小写字符。Unicode匹配（比如 Ü 匹配 ü）同样有用，除非设置了 re.ASCII 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 re.LOCALE 标记。这个相当于内联标记 (?i)</td>
    </tr>
    <tr>
      <td>re.L <br /> re.LOCALE</td>
      <td>由当前语言区域决定 \w, \W, \b, \B 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 (?L) 。</td>
    </tr>
    <tr>
      <td>re.M <br /> re.MULTILINE</td>
      <td>设置以后，样式字符 ‘^’ 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 ‘$’ 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，’^’ 匹配字符串头，’$’ 匹配字符串尾。对应内联标记 (?m)</td>
    </tr>
    <tr>
      <td>re.S <br /> re.DOTALL</td>
      <td>让 ‘.’ 特殊字符匹配任何字符，包括换行符；如果没有这个标记，’.’ 就匹配 除了 换行符的其他任意字符。对应内联标记 (?s)</td>
    </tr>
    <tr>
      <td>re.X <br /> re.VERBOSE</td>
      <td>这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 *?, (?: or (?P&lt;…&gt; 分组之内。当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。</td>
    </tr>
  </tbody>
</table>

<h1 id="2正则表达式对象">2.正则表达式对象</h1>

<h4 id="reregexobject">re.RegexObject</h4>

<p>re.compile() 返回 RegexObject 对象</p>

<h4 id="rematchobject">re.MatchObject</h4>

<p>group() 返回被 RE 匹配的字符串:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">start()</code>返回匹配开始的位置</li>
  <li><code class="language-plaintext highlighter-rouge">end() 返回匹配结束的位置</code></li>
  <li><code class="language-plaintext highlighter-rouge">span()</code> 返回一个元组包含匹配 (开始,结束) 的位置</li>
</ul>

<h1 id="3re模块内容">3.re模块内容</h1>

<table>
  <thead>
    <tr>
      <th>re模块</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>re.compile(pattern, flags=0)</td>
      <td>将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配</td>
    </tr>
    <tr>
      <td>re.search(pattern, string, flags=0)</td>
      <td>扫描整个 字符串 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 None ； 注意这和找到一个零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>re.match(pattern, string, flags=0)</td>
      <td>如果 string 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 None ；注意它跟零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>re.fullmatch(pattern, string, flags=0)</td>
      <td>如果整个 string 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 None ；注意这跟零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>re.split(pattern, string, maxsplit=0, flags=0)</td>
      <td>用 pattern 分开 string 。 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素</td>
    </tr>
    <tr>
      <td>re.findall(pattern, string, flags=0)</td>
      <td>对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里</td>
    </tr>
    <tr>
      <td>re.finditer(pattern, string, flags=0)</td>
      <td>pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里</td>
    </tr>
    <tr>
      <td>re.sub(pattern, repl, string, count=0, flags=0)</td>
      <td>返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。 如果样式没有找到，则不加改变地返回 string。 repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，\n 会被转换为一个换行符，\r 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 \&amp; 会保持原样。 向后引用像是 \6 会用样式中第 6 组所匹配到的子字符串来替换</td>
    </tr>
    <tr>
      <td>re.subn(pattern, repl, string, count=0, flags=0)</td>
      <td>行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数)</td>
    </tr>
    <tr>
      <td>re.escape(pattern)</td>
      <td>转义 pattern 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配</td>
    </tr>
    <tr>
      <td>re.purge()</td>
      <td>清除正则表达式缓存</td>
    </tr>
  </tbody>
</table>

<h1 id="4正则对象">4.正则对象</h1>

<p>编译后的正则表达式对象支持一下方法和属性</p>

<table>
  <thead>
    <tr>
      <th>正则对象</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pattern.search(string[, pos[, endpos]])</td>
      <td>扫描整个 string 寻找第一个匹配的位置， 并返回一个相应的 匹配对象。如果没有匹配，就返回 None ；注意它和零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>Pattern.match(string[, pos[, endpos]])</td>
      <td>如果 string 的 开始位置 能够找到这个正则样式的任意个匹配，就返回一个相应的 匹配对象。如果不匹配，就返回 None ；注意它与零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>Pattern.fullmatch(string[, pos[, endpos]])</td>
      <td>如果整个 string 匹配这个正则表达式，就返回一个相应的 匹配对象 。 否则就返回 None ； 注意跟零长度匹配是不同的</td>
    </tr>
    <tr>
      <td>Pattern.split(string, maxsplit=0)</td>
      <td>等价于 split() 函数，使用了编译后的样式</td>
    </tr>
    <tr>
      <td>Pattern.findall(string[, pos[, endpos]])</td>
      <td>类似函数 findall() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()</td>
    </tr>
    <tr>
      <td>Pattern.finditer(string[, pos[, endpos]])</td>
      <td>类似函数 finiter() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()</td>
    </tr>
    <tr>
      <td>Pattern.sub(repl, string, count=0)</td>
      <td>等价于 sub() 函数，使用了编译后的样式</td>
    </tr>
    <tr>
      <td>Pattern.subn(repl, string, count=0)</td>
      <td>等价于 subn() 函数，使用了编译后的样式</td>
    </tr>
    <tr>
      <td>Pattern.flags</td>
      <td>正则匹配标记。这是可以传递给 compile() 的参数，任何 (?…) 内联标记，隐性标记比如 UNICODE 的结合</td>
    </tr>
    <tr>
      <td>Pattern.groups</td>
      <td>捕获组合的数量</td>
    </tr>
    <tr>
      <td>Pattern.groupindex</td>
      <td>映射由 (?P<id>) 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的</id></td>
    </tr>
    <tr>
      <td>Pattern.pattern</td>
      <td>编译对象的原始样式字符串</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">注意</code>：通过 re.compile() 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>

<h1 id="5匹配对象">5.匹配对象</h1>

<p>匹配对象支持以下方法和属性</p>

<table>
  <thead>
    <tr>
      <th>匹配对象</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Match.expand(template)</td>
      <td>对 template 进行反斜杠转义替换并且返回，就像 sub() 方法中一样。转义如同 \n 被转换成合适的字符，数字引用(\1, \2)和命名组合(\g&lt;1&gt;, \g<name>) 替换为相应组合的内容</name></td>
    </tr>
    <tr>
      <td>Match.group([group1, …])</td>
      <td>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）</td>
    </tr>
    <tr>
      <td>Match.<strong>getitem</strong>(g)</td>
      <td>这个等价于 m.group(g)。这允许更方便的引用一个匹配</td>
    </tr>
    <tr>
      <td>Match.groups(default=None)</td>
      <td>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 default 参数用于不参与匹配的情况，默认为 None</td>
    </tr>
    <tr>
      <td>Match.groupdict(default=None)</td>
      <td>返回一个字典，包含了所有的 命名 子组。key就是组名。 default 参数用于不参与匹配的组合；默认为 None。</td>
    </tr>
    <tr>
      <td>Match.start([group]) <br /> Match.end([group])</td>
      <td>返回 group 匹配到的字串的开始和结束标号。group 默认为0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1 。对于一个匹配对象 m， 和一个未参与匹配的组 g ，组 g (等价于 m.group(g))产生的匹配是</td>
    </tr>
    <tr>
      <td>Match.span([group])</td>
      <td>对于一个匹配 m ， 返回一个二元组 (m.start(group), m.end(group)) 。 注意如果 group 没有在这个匹配中，就返回 (-1, -1) 。group 默认为0，就是整个匹配</td>
    </tr>
    <tr>
      <td>Match.pos</td>
      <td>pos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎开始在字符串搜索一个匹配的索引位置</td>
    </tr>
    <tr>
      <td>Match.endpos</td>
      <td>endpos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎停止在字符串搜索一个匹配的索引位置</td>
    </tr>
    <tr>
      <td>Match.lastindex</td>
      <td>捕获组的最后一个匹配的整数索引值，或者 None 如果没有匹配产生的话。比如，对于字符串 ‘ab’，表达式 (a)b, ((a)(b)), 和 ((ab)) 将得到 lastindex == 1 ， 而 (a)(b) 会得到 lastindex == 2</td>
    </tr>
    <tr>
      <td>Match.lastgroup</td>
      <td>最后一个匹配的命名组名字，或者 None 如果没有产生匹配的话</td>
    </tr>
    <tr>
      <td>Match.re</td>
      <td>返回产生这个实例的 正则对象 ， 这个实例是由 正则对象的 match() 或 search() 方法产生的</td>
    </tr>
    <tr>
      <td>Match.string</td>
      <td>传递到 match() 或 search() 的字符串</td>
    </tr>
  </tbody>
</table>

<h1 id="6正则前缀r">6.正则前缀r</h1>

<p>以r或R开头的python中的字符串表示（非转义的）<a href="/python/2019/06/17/python-3.html#2%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2" title="/python/2019/06/17/python-3.html#2%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2">原始字符串 传送门</a>请查看<a href="/python/2019/06/17/python-3.html" title="/python/2019/06/17/python-3.html">字符串章节</a>原始字符串定义</p>

<p>当我们匹配一个路径时<code class="language-plaintext highlighter-rouge">c:\\test</code>，假如需要匹配文本中<code class="language-plaintext highlighter-rouge">\</code>,那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#添加r
</span><span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s">"c:\\test"</span><span class="p">,</span><span class="s">'c:</span><span class="se">\\</span><span class="s">test'</span><span class="p">).</span><span class="n">group</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span>
<span class="s">'c:</span><span class="se">\\</span><span class="s">test'</span>

<span class="c1">#不添加r
</span><span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">"c:</span><span class="se">\\\\</span><span class="s">test"</span><span class="p">,</span><span class="s">'c:</span><span class="se">\\</span><span class="s">test'</span><span class="p">).</span><span class="n">group</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span>
<span class="s">'c:</span><span class="se">\\</span><span class="s">test'</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">注意：在正则中添加r前缀一般用于路径匹配较多</code></p>

<h1 id="7判断是否匹配成功">7.判断是否匹配成功</h1>

<p><code class="language-plaintext highlighter-rouge">match()</code>方法判断是否匹配，如果匹配成功，返回一个<code class="language-plaintext highlighter-rouge">Match</code>对象，否则返回<code class="language-plaintext highlighter-rouge">None</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#验证手机号
</span><span class="n">test</span> <span class="o">=</span> <span class="s">"15525341345"</span>
<span class="k">if</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'^1(3|4|5|7|8)\d{9}$'</span><span class="p">,</span><span class="n">test</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'ok'</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'failed'</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="8获取正则匹配内容">8.获取正则匹配内容</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="s">'123asdf298adsfa'</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(\d+)[a-z]+(\d+)'</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span>
<span class="p">[(</span><span class="s">'123'</span><span class="p">,</span> <span class="s">'298'</span><span class="p">)]</span>
</code></pre></div></div>

<p>####使用match获取匹配内容</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="s">'123asdf298adsfa'</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'(\d+)[a-z]+(\d+)'</span><span class="p">,</span><span class="n">s</span><span class="p">).</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret</span>
<span class="p">(</span><span class="s">'010'</span><span class="p">,</span> <span class="s">'12345'</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="9贪婪与非贪婪">9.贪婪与非贪婪</h1>

<p><code class="language-plaintext highlighter-rouge">贪婪</code>与<code class="language-plaintext highlighter-rouge">非贪婪</code>模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配, python中默认是<code class="language-plaintext highlighter-rouge">贪婪模式</code></p>

<p><code class="language-plaintext highlighter-rouge">非贪婪</code>在数量词后面添加一个<code class="language-plaintext highlighter-rouge">?</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 贪婪
</span><span class="n">s</span> <span class="o">=</span> <span class="s">'python 111java678php'</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[a-z]{3,6}'</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span>
<span class="p">[</span><span class="s">'python'</span><span class="p">,</span> <span class="s">'java'</span><span class="p">,</span> <span class="s">'php'</span><span class="p">]</span>

<span class="c1"># 非贪婪 
</span><span class="n">s</span> <span class="o">=</span> <span class="s">'python 111java678php'</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'[a-z]{3,6}?'</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span>
<span class="p">[</span><span class="s">'pyt'</span><span class="p">,</span> <span class="s">'hon'</span><span class="p">,</span> <span class="s">'jav'</span><span class="p">,</span> <span class="s">'php'</span><span class="p">]</span>
</code></pre></div></div>

<h1 id="10正则替换">10.正则替换</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="s">'hello'</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="s">'ll'</span><span class="p">,</span><span class="s">'yy'</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">r</span>
<span class="s">'heyyo'</span>
</code></pre></div></div>

:ET
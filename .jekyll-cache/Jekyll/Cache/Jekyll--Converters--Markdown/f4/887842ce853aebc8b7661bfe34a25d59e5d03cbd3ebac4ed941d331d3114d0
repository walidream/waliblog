I"J<p>在计算机科学中，查找表（Lookup Table）是用简单的查询操作替换运行时计算的数组或者关联数组这样的数据结构。由于从内存中提取数值经常要比复杂的计算速度快很多，所以这样得到的速度提升是很显著的。</p>

<table>
  <thead>
    <tr>
      <th>关键字</th>
      <th>描述</th>
      <th>示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>AS</td>
      <td>(别名)修改显示字段</td>
      <td>select hello as ‘名字’</td>
    </tr>
    <tr>
      <td>DISTINCT</td>
      <td>去重复关键字,SELECT DISTINCT 语句用于返回唯一不同的值</td>
      <td>select distinct c_type from commodity;</td>
    </tr>
    <tr>
      <td>WHERE</td>
      <td>条件</td>
      <td>SELECT column_name,column_name<br />FROM table_name<br />WHERE column_name operator value;</td>
    </tr>
    <tr>
      <td>BETWEEN AND</td>
      <td>取值范围</td>
      <td>select c_name,c_inprice<br />from commodity<br />where c_inprice between 10 and 100;</td>
    </tr>
    <tr>
      <td>NOT BETWEEN AND</td>
      <td>不在这个取值范围</td>
      <td>select c_name,c_inprice<br />from commodity<br />where c_inprice not between 10 and 100;</td>
    </tr>
    <tr>
      <td>IS NULL</td>
      <td>选项有null值</td>
      <td>select c_name ,c_inprice,c_outprice<br />from commodity<br />where c_outprice is null;</td>
    </tr>
    <tr>
      <td>IS NOT NULL</td>
      <td>选项没有null值</td>
      <td>select c_name ,c_inprice,c_outprice<br />from commodity<br />where c_outprice is not null;</td>
    </tr>
    <tr>
      <td>IN</td>
      <td>(10,20,30,40) 括号条件满足任意一个,是or关系</td>
      <td>select c_name,c_inprice,c_outprice<br />from commodity<br />where c_inprice in (20,10,30,40);</td>
    </tr>
    <tr>
      <td>NOT IN</td>
      <td>(10,20,30,40) 不满足以上全部条件</td>
      <td>select c_name,c_inprice,c_outprice<br />from commodity<br />where c_inprice not in (20,10,30,40);</td>
    </tr>
    <tr>
      <td>LIKE</td>
      <td>和通配符搭配<br />‘_‘任意一个字符<br />’%’ 匹配任意多个字符,包括零个字符<br />没有通配符修饰 效果等同于’=’<br />’%%’表示全部</td>
      <td>select c_name<br />from commodity<br />where c_name like ‘%以%’;</td>
    </tr>
    <tr>
      <td>ORDER BY</td>
      <td>排序(默认升序)</td>
      <td>select c_name,c_inprice<br />from commodity<br />order by c_inprice;</td>
    </tr>
    <tr>
      <td>ORDER BY 字段 desc</td>
      <td>降序</td>
      <td>select c_name,c_inprice<br />from commodity<br />order by c_inprice desc;</td>
    </tr>
    <tr>
      <td>LIMIT</td>
      <td>limit 值1,值2<br /><code class="language-plaintext highlighter-rouge">值1</code>表示下标，<code class="language-plaintext highlighter-rouge">值2</code>表示多少行; 当只有一个值时，那就表示前<code class="language-plaintext highlighter-rouge">多少行</code></td>
      <td>select c_name,c_outprice<br />from commodity<br />where c_outprice is not null<br />order by  c_outprice desc<br />limit 5;</td>
    </tr>
    <tr>
      <td>GROUP BY</td>
      <td>分组</td>
      <td>select count(*),c_type<br />from commodity<br />group by c_type;</td>
    </tr>
    <tr>
      <td>HAVING</td>
      <td>可以和统计函数一起使用,如果查询语句中出现两个关键字where和having,则where优先级大于having；<br />是where将限制语句输出之后，having根据输出结果来进行判断<br />HAVING子句必须位于GROUP BY之后ORDER BY之前</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h1 id="1常用系统函数">1.常用系统函数</h1>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>count()</td>
      <td>统计记录个数,参数是字段,也可以是count(*)</td>
    </tr>
    <tr>
      <td>avg()</td>
      <td>统计平均值,参数是字段,但是数据类型是整型</td>
    </tr>
    <tr>
      <td>max()</td>
      <td>最大值</td>
    </tr>
    <tr>
      <td>min()</td>
      <td>最小值</td>
    </tr>
  </tbody>
</table>

<h1 id="2常用语句">2.常用语句</h1>

<h3 id="查询语句-select">查询语句 select</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">table_name</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="删除语句-delete">删除语句 delete</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="k">from</span> <span class="k">table_name</span>
<span class="k">where</span> <span class="n">c_name</span><span class="o">=</span><span class="s1">'中国'</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="更新数据-update">更新数据 update</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">update</span> <span class="k">table_name</span>
<span class="k">set</span> <span class="n">column1</span><span class="o">=</span><span class="n">value1</span><span class="p">,</span><span class="n">column2</span><span class="o">=</span><span class="n">value2</span>
<span class="k">where</span> <span class="n">some_colum</span><span class="o">=</span><span class="n">some_value</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="清空表数据-truncate">清空表数据 truncate</h3>

<p><code class="language-plaintext highlighter-rouge">有外键约束的不能删除</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">truncate</span> <span class="k">table</span> <span class="k">table_name</span>
</code></pre></div></div>

<h3 id="添加数据-inser-into">添加数据 inser into</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inser</span> <span class="k">into</span> <span class="k">table_name</span>
<span class="k">values</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span><span class="n">value2</span><span class="p">,</span><span class="n">value3</span><span class="p">,...);</span>
<span class="c1">--或者</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span> <span class="n">field1</span><span class="p">,</span> <span class="n">field2</span><span class="p">,...</span><span class="n">fieldN</span> <span class="p">)</span>
                       <span class="k">VALUES</span>
                       <span class="p">(</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,...</span><span class="n">valueN</span> <span class="p">);</span>
</code></pre></div></div>

<p>小菜在这里链接一个测试的表，想练习的小伙伴们下载<a href="http://walidream.com/waliData/school.sql" download="school.sql">练习表查询sql表</a></p>

<h1 id="3子查询">3.子查询</h1>

<p>在一个表表达中可以调用另一个表表达式，这个被调用的表表达式叫做子查询（subquery）</p>

<h4 id="使用子查询原则">使用子查询原则</h4>

<ul>
  <li>一个子查询必须放在圆括号中</li>
  <li>将子查询放在比较条件的右边以增加可读性。子查询不包含 ORDER BY 子句。对一个 SELECT 语句只能用一个 ORDER BY 子句，并且如果指定了它就必须放在主 SELECT 语句的最后</li>
  <li>在子查询中可以使用两种比较条件：单行运算符(&gt;, =, &gt;=, &lt;, &lt;&gt;, &lt;=) 和多行运算符(IN, ANY, ALL)</li>
</ul>

<h4 id="按照对返回结果的调用方法">按照对返回结果的调用方法:</h4>

<ul>
  <li>where型子查询：把内层查询结果当作外层查询的比较条件</li>
  <li>from型子查询：把内层的查询结果供外层再次查询</li>
  <li>exists型子查询：把外层查询结果拿到内层，看内层的查询是否成立</li>
</ul>

<h3 id="where型子查询">where型子查询</h3>

<p>where型的子查询就是把内层查询的结果当作外层查询的条件</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--查找'4'(net)课程成绩最高学生姓名</span>
<span class="k">SELECT</span> <span class="n">s</span><span class="p">.</span><span class="n">s_name</span>
<span class="k">FROM</span> <span class="n">student</span> <span class="n">s</span>
<span class="k">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">s_id</span> <span class="o">=</span> <span class="p">(</span>
	<span class="k">SELECT</span> <span class="n">sc</span><span class="p">.</span><span class="n">s_id</span>
	<span class="k">FROM</span> <span class="n">score</span> <span class="n">sc</span>
	<span class="k">WHERE</span> <span class="n">sc</span><span class="p">.</span><span class="n">c_id</span> <span class="o">=</span> <span class="mi">4</span>
	<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">sc</span><span class="p">.</span><span class="n">s_score</span> <span class="k">DESC</span>
	<span class="k">LIMIT</span> <span class="mi">1</span>
<span class="p">)</span>
</code></pre></div></div>

<h3 id="from型子查询">from型子查询</h3>

<p>from子查询就是把子查询的结果(内存里的一张表)当作一张临时表，然后再对它进行处理</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--查询'3'(java)课程比'4'(net)课程成绩高的所有学生的学号</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">s_id</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">score</span> <span class="n">sc</span> <span class="k">WHERE</span> <span class="n">sc</span><span class="p">.</span><span class="n">c_id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="n">a</span><span class="p">,</span>
     <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">score</span> <span class="n">sc</span> <span class="k">WHERE</span> <span class="n">sc</span><span class="p">.</span><span class="n">c_id</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">b</span>
<span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">s_id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">s_id</span> 
    <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">s_score</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">s_score</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="exists型子查询">exists型子查询</h3>

<p>exists子查询就是对外层表进行循环，再对内表进行内层查询。和in ()差不多，但是它们还是有区别的。主要是看两个张表大小差的程度。若子查询表大则用exists（内层索引），子查询表小则用in（外层索引）</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">--查询学生姓名和老师姓名冲突的人</span>
<span class="k">SELECT</span> <span class="n">s</span><span class="p">.</span><span class="n">s_name</span>
<span class="k">FROM</span> <span class="n">student</span> <span class="n">s</span>
<span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span>
	<span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">t_name</span>
	<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span>
	<span class="k">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">s_name</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">t_name</span>
<span class="p">)</span>

<span class="c1">--也可以转换成in</span>
<span class="k">SELECT</span> <span class="n">s</span><span class="p">.</span><span class="n">s_name</span>
<span class="k">FROM</span> <span class="n">student</span> <span class="n">s</span>
<span class="k">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">s_name</span> <span class="k">in</span> <span class="p">(</span>
	<span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">t_name</span>
	<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span>
<span class="p">)</span>
</code></pre></div></div>

<p>在sql中需要使用两张表以上时，需要使用<code class="language-plaintext highlighter-rouge">join</code>,join又分为5种：</p>
<ul>
  <li>内连接(INNER)</li>
  <li>全外连接(FULL OUTER)</li>
  <li>左外连接(LEFT OUTER)</li>
  <li>右外连接(RIGHT OUTER)</li>
  <li>交叉连接(CROSS)</li>
</ul>

<h1 id="4内连接">4.内连接</h1>

<p>内连接Inner join 基于连接谓词将两张表(如A 和 B)的列组合在一起，产生新的结果集(其实就是两张表的公共部分,可以理解为两个圆的交集)。</p>

<p><img src="http://walidream.com:9999/blogImage/server/server_33.png" alt="ssl" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">course</span> <span class="k">c</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">t_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">c_id</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="http://walidream.com:9999/blogImage/server/server_34.png" alt="ssl" /></p>

<h1 id="5全外连接">5.全外连接</h1>

<p>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。使用全连接可以得到以下两种结果</p>

<p><code class="language-plaintext highlighter-rouge">注意：mysql中不支持full join操作</code>，但是可以通过左连接并上右连接达到全连接效果</p>

<p><img src="http://walidream.com:9999/blogImage/server/server_39.png" alt="ssl" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">course</span> <span class="k">c</span> <span class="k">ON</span> <span class="n">t</span><span class="p">.</span><span class="n">t_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">t_id</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> 
<span class="k">FROM</span> <span class="n">course</span> <span class="k">c</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">teacher</span> <span class="n">t</span> <span class="k">ON</span> <span class="n">t</span><span class="p">.</span><span class="n">t_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">t_id</span>
</code></pre></div></div>

<p><img src="http://walidream.com:9999/blogImage/server/server_43.png" alt="ssl" /></p>

<h1 id="6左外连接">6.左外连接</h1>

<p><code class="language-plaintext highlighter-rouge">LEFT JOIN</code>关键字会将左表作为主表(A)，将返回所有行，即使在右表(B)中没有匹配的行会以<code class="language-plaintext highlighter-rouge">NULL</code>显示。</p>

<p><img src="http://walidream.com:9999/blogImage/server/server_35.png" alt="ssl" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">course</span> <span class="k">c</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">t_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">t_id</span>
</code></pre></div></div>
<p><img src="http://walidream.com:9999/blogImage/server/server_36.png" alt="ssl" /></p>

<h1 id="7右外连接">7.右外连接</h1>

<p>RIGHT JOIN 关键字会右表作为主表(B)，将返回所有行，即使在左表(A)中没有匹配的行会以<code class="language-plaintext highlighter-rouge">NULL</code>显示。</p>

<p><img src="http://walidream.com:9999/blogImage/server/server_37.png" alt="ssl" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">teacher</span> <span class="n">t</span> <span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">course</span> <span class="k">c</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">t_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">t_id</span>
</code></pre></div></div>
<p><img src="http://walidream.com:9999/blogImage/server/server_38.png" alt="ssl" /></p>

<h1 id="8交叉连接">8.交叉连接</h1>

<p>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积</p>

<p><img src="http://walidream.com:9999/blogImage/server/server_42.png" alt="ssl" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">teacher</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">course</span> 
</code></pre></div></div>

<p><img src="http://walidream.com:9999/blogImage/server/server_41.png" alt="ssl" /></p>

:ET